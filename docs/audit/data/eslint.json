[{"filePath":"/home/engine/project/src/background.js","messages":[{"ruleId":"no-prototype-builtins","severity":2,"message":"Do not access Object.prototype method 'hasOwnProperty' from target object.","line":2,"column":48,"nodeType":"CallExpression","messageId":"prototypeBuildIn","endLine":2,"endColumn":62,"suggestions":[{"messageId":"callObjectPrototype","data":{"prop":"hasOwnProperty"},"fix":{"range":[59,117],"text":"Object.prototype.hasOwnProperty.call(chrome.webRequest.OnHeadersReceivedOptions, "},"desc":"Call Object.prototype.hasOwnProperty explicitly."}]},{"ruleId":"no-prototype-builtins","severity":2,"message":"Do not access Object.prototype method 'hasOwnProperty' from target object.","line":72,"column":19,"nodeType":"CallExpression","messageId":"prototypeBuildIn","endLine":72,"endColumn":33,"suggestions":[{"messageId":"callObjectPrototype","data":{"prop":"hasOwnProperty"},"fix":{"range":[2623,2643],"text":"Object.prototype.hasOwnProperty.call(urls, "},"desc":"Call Object.prototype.hasOwnProperty explicitly."}]},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":101,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":101,"endColumn":19},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":101,"column":21,"nodeType":"BlockStatement","messageId":"unexpected","endLine":101,"endColumn":23,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[3831,3831],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const extraInfoSpec = [\"blocking\", \"responseHeaders\"];\nif (chrome.webRequest.OnHeadersReceivedOptions.hasOwnProperty(\"EXTRA_HEADERS\")) {\n    extraInfoSpec.push(\"extraHeaders\");\n}\n\nchrome.webRequest.onHeadersReceived.addListener(\n    function(details) {\n        let headers = details.responseHeaders.filter(header => header.name.toLowerCase() !== 'content-security-policy' && header.name.toLowerCase() !== 'location');\n        return {\n            responseHeaders: headers\n        }\n    },\n    {urls: [\"https://twitter.com/i/tweetdeck\", \"https://x.com/i/tweetdeck\", \"https://x.com/i/tweetdeck?*\"]},\n    extraInfoSpec\n);\n\nchrome.webRequest.onBeforeSendHeaders.addListener(\n    function(details) {\n        let headers = details.requestHeaders.filter(header => header.name.toLowerCase() !== 'referer');\n        return {\n            requestHeaders: headers\n        }\n    },\n    {urls: [\"https://twitter.com/i/api/graphql/*\", \"https://x.com/i/api/graphql/*\"]},\n    extraInfoSpec.map(s => s.replace('response', 'request'))\n)\n\nchrome.webRequest.onBeforeRequest.addListener(\n    function() {\n        return {\n            redirectUrl: 'https://twitter.com/i/tweetdeck'\n        }\n    },\n    {urls: [\"https://tweetdeck.twitter.com/*\", \"https://tweetdeck.x.com/*\"]},\n    [\"blocking\"]\n);\n\nchrome.webRequest.onBeforeRequest.addListener(\n    function() {\n        return {\n            redirectUrl: 'https://twitter.com/i/tweetdeck'\n        }\n    },\n    {urls: [\"https://tweetdeck.com/*\"]},\n    [\"blocking\"]\n);\n\nconst isFirefox = typeof browser !== \"undefined\";\n\n// Store the URL of the tab that initiated the request.\nlet urls = {};\n\nconst flushCache = chrome.webRequest.handlerBehaviorChanged;\n\nchrome.webNavigation.onCommitted.addListener(\n    function (details) {\n        // Flushes in-memory cache when moving from other twitter.com sites to TweetDeck,\n        // because if cache hits, `onBeforeRequest` event won't be called (and thus we can't block unwanted requests below).\n        // Only needed in Chrome. See: https://developer.chrome.com/docs/extensions/reference/webRequest/#caching\n        if (\n            !isFirefox &&\n            (urls[details.tabId]?.[details.frameId].startsWith(\"https://twitter.com/\") || urls[details.tabId]?.[details.frameId].startsWith(\"https://x.com/\")) &&\n            details.transitionType !== \"reload\" &&\n            (details.url === \"https://twitter.com/i/tweetdeck\" || details.url === \"https://x.com/i/tweetdeck\")\n        ) {\n            flushCache();\n        // Update stored URL\n        }\n        if (details.tabId === -1 || details.frameId !== 0) {\n            return;\n        }\n        if (!urls.hasOwnProperty(details.tabId)) {\n            urls[details.tabId] = {};\n        }\n        urls[details.tabId][details.frameId] = details.url;\n    },\n    { url: [{ hostSuffix: \"twitter.com\" }, { hostSuffix: \"x.com\" }] },\n);\n\n// Block requests for files related to Web App, except for main.{random}.js (which may be needed for API connection)\nchrome.webRequest.onBeforeRequest.addListener(\n    function (details) {\n        try {\n            let parsedUrl = new URL(details.url);\n            let path = parsedUrl.pathname;\n            // want to use details.originUrl but it's not available in Chrome\n            let requestFrom = urls[details.tabId][details.frameId];\n            if (\n                (\n                    path.startsWith(\"/responsive-web/client-web-legacy/\") ||\n                    path.startsWith(\"/responsive-web/client-web/\")\n                ) &&\n                (requestFrom === \"https://twitter.com/i/tweetdeck\" || requestFrom === \"https://x.com/i/tweetdeck\") &&\n                !path.includes('ondemand.s.') &&\n                !path.includes('vendor.')\n            ) {\n                return {\n                    cancel: true,\n                };\n            }\n        } catch (e) {}\n    },\n    { urls: [\"https://abs.twimg.com/*\"] },\n    [\"blocking\"],\n);\n\nchrome.runtime.onMessage.addListener(async (request, sender, sendResponse) => {\n    if(request.action === 'setcookie') {\n        chrome.cookies.getAll({url: \"https://x.com\"}, async cookies => {\n            console.log('setcookie', cookies);\n            chrome.tabs.query({ active: true, lastFocusedWindow: true }, tab => {\n                tab = tab[0];\n                chrome.cookies.getAllCookieStores(async cookieStores => {\n                    console.log('cookieStores', cookieStores, tab);\n                    const storeId = cookieStores?.find( cookieStore => cookieStore?.tabIds?.indexOf(tab?.id) !== -1)?.id;\n\n                    for(let cookie of cookies) {\n                        chrome.cookies.set({\n                            url: \"https://twitter.com\",\n                            name: cookie.name,\n                            value: cookie.value,\n                            expirationDate: cookie.expirationDate,\n                            domain: \".twitter.com\",\n                            sameSite: cookie.sameSite,\n                            secure: cookie.secure,\n                            httpOnly: cookie.httpOnly,\n                            storeId\n                        }, () => {\n                            console.log('set cookie', cookie, storeId);\n                        });\n                    }\n                });\n            });\n        });\n    } else if(request.action === 'getcookie') {\n        chrome.cookies.getAll({url: \"https://x.com\"}, async cookies => {\n            console.log('getcookie', cookies);\n            sendResponse(cookies);\n        });\n        return true;\n    }\n});","usedDeprecatedRules":[]},{"filePath":"/home/engine/project/src/background3.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/engine/project/src/challenge.js","messages":[{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'solveChallenge' is defined but never used. Allowed unused vars must match /^_/u.","line":86,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":86,"endColumn":24,"suggestions":[{"messageId":"removeVar","data":{"varName":"solveChallenge"},"fix":{"range":[3045,4671],"text":""},"desc":"Remove unused variable 'solveChallenge'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"let solveId = 0;\nlet solveCallbacks = {};\nlet solverErrored = false;\nlet ready = false;\n\nlet solverIframe = document.createElement('iframe');\nsolverIframe.style.position = 'absolute';\nsolverIframe.width = '0px';\nsolverIframe.height = '0px';\nsolverIframe.style.border = 'none';\nsolverIframe.style.opacity = 0;\nsolverIframe.style.pointerEvents = 'none';\nsolverIframe.tabIndex = -1;\nsolverIframe.src = \"https://tweetdeck.dimden.dev/solver.html?4\"; // check source code of that page to make sure its safe if u dont trust it\nfetch(solverIframe.src).catch(() => {\n    console.error(\"Cannot load solver iframe\");\n    solverErrored = true;\n    for(let id in solveCallbacks) {\n        solveCallbacks[id].reject('Solver errored');\n        delete solveCallbacks[id];\n    }\n});\nlet injectedBody = document.getElementById('injected-body');\nif(injectedBody) injectedBody.appendChild(solverIframe);\nelse {\n    let int = setInterval(() => {\n        injectedBody = document.getElementById('injected-body');\n        if(injectedBody) {\n            clearInterval(int);\n            injectedBody.appendChild(solverIframe);\n        }\n    }, 50);\n}\n\nfunction uuidV4() {\n    const uuid = new Array(36);\n    for (let i = 0; i < 36; i++) {\n      uuid[i] = Math.floor(Math.random() * 16);\n    }\n    uuid[14] = 4; // set bits 12-15 of time-high-and-version to 0100\n    uuid[19] = uuid[19] &= ~(1 << 2); // set bit 6 of clock-seq-and-reserved to zero\n    uuid[19] = uuid[19] |= (1 << 3); // set bit 7 of clock-seq-and-reserved to one\n    uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';\n    return uuid.map((x) => x.toString(16)).join('');\n}\n\nasync function readCryptoKey() {\n    return new Promise((resolve, reject) => {\n        let request = indexedDB.open(\"localforage\");\n\n        request.onerror = function(event) {\n            reject(event);\n        };\n\n        request.onsuccess = function(event) {\n            const db = event.target.result;\n\n            // Open a transaction to access the keyvaluepairs object store\n            if (db.objectStoreNames.contains('keyvaluepairs')) {\n                const transaction = db.transaction(['keyvaluepairs'], 'readonly');\n                const objectStore = transaction.objectStore('keyvaluepairs');\n            \n                objectStore.openCursor().onsuccess = function(event) {\n                    const cursor = event.target.result;\n                    if (cursor) {\n                        // Check if the key matches the pattern\n                        const key = cursor.key;\n                        if (key.startsWith('device:rweb.dmCryptoKeys')) {\n                            resolve(cursor.value);\n                        }\n                \n                        // Move to the next entry\n                        cursor.continue();\n                    } else {\n                        // No more entries, reject the promise\n                        reject(\"No key found\");\n                    }\n                };\n            } else {\n                reject(\"No key found\");\n            }\n        };\n    });\n}\n\nfunction solveChallenge(path, method) {\n    return new Promise((resolve, reject) => {\n        if(solverErrored) {\n            reject('Solver errored');\n            return;\n        }\n        let id = solveId++;\n        solveCallbacks[id] = { resolve, reject, time: Date.now() };\n        if(!solverIframe.contentWindow) {\n            solverIframe.addEventListener('load', () => {\n                solverIframe.contentWindow.postMessage({ action: 'solve', id, path, method }, '*');\n                setTimeout(() => {\n                    if(solveCallbacks[id]) {\n                        // try again\n                        solverIframe.contentWindow.postMessage({ action: 'solve', id, path, method }, '*');\n                    }\n                }, 5000);\n                setTimeout(() => {\n                    if(solveCallbacks[id]) {\n                        solveCallbacks[id].reject('Solver timed out');\n                        delete solveCallbacks[id];\n                    }\n                }, 20000);\n            });\n        } else {\n            solverIframe.contentWindow.postMessage({ action: 'solve', id, path, method }, '*');\n            setTimeout(() => {\n                if(solveCallbacks[id]) {\n                    // try again\n                    solverIframe.contentWindow.postMessage({ action: 'solve', id, path, method }, '*');\n                }\n            }, 5000);\n            setTimeout(() => {\n                if(solveCallbacks[id]) {\n                    solveCallbacks[id].reject('Solver timed out');\n                    delete solveCallbacks[id];\n                }\n            }, 20000);\n        }\n    });\n}\n\nwindow.addEventListener('message', e => {\n    if(e.source !== solverIframe.contentWindow) return;\n    let data = e.data;\n    if(data.action === 'solved') {\n        let { id, result } = data;\n        if(solveCallbacks[id]) {\n            solveCallbacks[id].resolve(result);\n            delete solveCallbacks[id];\n        }\n    } else if(data.action === 'error') {\n        let { id, error } = data;\n        if(solveCallbacks[id]) {\n            solveCallbacks[id].reject(error);\n            delete solveCallbacks[id];\n        }\n    } else if(data.action === 'initError') {\n        console.error('Solver init error:', data.error);\n        solverErrored = true;\n        for(let id in solveCallbacks) {\n            solveCallbacks[id].reject('Solver errored');\n            delete solveCallbacks[id];\n        }\n    } else if(data.action === 'ready') {\n        ready = true;\n    }\n});\n\n(async () => {\n    try {\n        try {\n            let cryptoKey = await readCryptoKey();\n            if(cryptoKey) {\n                localStorage.device_id = cryptoKey.deviceId;\n            } else if(!localStorage.device_id) {\n                localStorage.device_id = uuidV4();\n            }\n        } catch(e) {\n            console.warn(`Error during device id generation:`, e);\n            if(!localStorage.device_id) {\n                localStorage.device_id = uuidV4();\n            }\n        }\n\n        let homepageData = await fetch(`https://${location.hostname}/`).then(res => res.text());\n        let dom = new DOMParser().parseFromString(homepageData, 'text/html');\n        let anims = Array.from(dom.querySelectorAll('svg[id^=\"loading-x\"]')).map(svg => svg.outerHTML);\n\n        let vendorCode = homepageData.match(/vendor.(\\w+).js\"/)[1];\n        let challengeCode = homepageData.match(/\"ondemand.s\":\"(\\w+)\"/)[1];\n        let challengeData = await fetch(`https://abs.twimg.com/responsive-web/client-web/ondemand.s.${challengeCode}a.js`).then(res => res.text());\n        console.log(`Successfully fetched challenge data (${challengeCode} / ${challengeData.length})`);\n        let vendorData = await fetch(`https://abs.twimg.com/responsive-web/client-web/vendor.${vendorCode}.js`).then(res => res.text());\n        console.log(`Successfully fetched vendor data (${vendorCode} / ${vendorData.length})`);\n\n        function sendInit() {\n            console.log('Sending init');\n            solverIframe.contentWindow.postMessage({\n                action: 'init',\n                challenge: challengeData,\n                vendor: vendorData,\n                anims,\n                verificationCode: dom.querySelector('meta[name=\"twitter-site-verification\"]').content,\n            }, '*');\n        }\n        if(solverIframe.contentWindow) {\n            sendInit();\n            setTimeout(() => {\n                if(!ready) {\n                    sendInit();\n                }\n            }, 2500);\n        } else {\n            setTimeout(() => {\n                if(!ready) {\n                    sendInit();\n                }\n            }, 2500);\n            solverIframe.addEventListener('load', () => sendInit());\n        }\n    } catch (e) {\n        console.error(`Error during challenge:`);\n        console.error(e);\n    }\n})()","usedDeprecatedRules":[]},{"filePath":"/home/engine/project/src/content.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/engine/project/src/destroyer.js","messages":[{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":28,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":28,"endColumn":14},{"ruleId":"no-unsafe-finally","severity":2,"message":"Unsafe usage of ReturnStatement.","line":31,"column":9,"nodeType":"ReturnStatement","messageId":"unsafeUsage","endLine":31,"endColumn":53},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":43,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":43,"endColumn":14},{"ruleId":"no-unsafe-finally","severity":2,"message":"Unsafe usage of ReturnStatement.","line":46,"column":9,"nodeType":"ReturnStatement","messageId":"unsafeUsage","endLine":46,"endColumn":53}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Step 1: fool twitter into thinking scripts loaded\nwindow.__SCRIPTS_LOADED__ = Object.freeze({\n    main: true,\n    vendor: true,\n    runtime: false\n});\n\n// Step 2: continously wreck havoc\nlet _destroyerInt = setInterval(() => {\n    delete window.webpackChunk_twitter_responsive_web;\n    window.__SCRIPTS_LOADED__ = Object.freeze({\n        main: true,\n        vendor: true,\n        runtime: false\n    });\n    if(document.getElementById('ScriptLoadFailure')) {\n        document.getElementById('ScriptLoadFailure').remove();\n    }\n});\n\n// Step 3: destroy twitter critical modules\nlet _originalPush = Array.prototype.push;\nArray.prototype.push = function() {\n    try {\n        if(arguments[0]?.[0]?.[0] === \"vendor\" || arguments[0]?.[0]?.[0] === \"main\") {\n            throw \"Twitter killing magic killed Twitter https://lune.dimden.dev/f016efffcd3d.png (thats fine)\";\n        }\n    } catch(e) {\n        Array.prototype.push = _originalPush;\n    } finally {\n        return _originalPush.apply(this, arguments);\n    }\n}\n\n// Step 4: prevent twitter from reporting it\nlet _originalTest = RegExp.prototype.test;\nRegExp.prototype.test = function() {\n    try {\n        if(this.toString() === '/[?&]failedScript=/') {\n            RegExp.prototype.test = _originalTest;\n            throw \"hehe\";\n        };\n    } catch(e) {\n        RegExp.prototype.test = _originalTest;\n    } finally {\n        return _originalTest.apply(this, arguments);\n    }\n}\n\n// Step 5: self destruct\nsetTimeout(() => {\n    clearInterval(_destroyerInt);\n    Array.prototype.push = _originalPush;\n    RegExp.prototype.test = _originalTest;\n}, 5000);\n\n// Step 6: Live OTD reaction: https://lune.dimden.dev/6743b45eb1de.png","usedDeprecatedRules":[]},{"filePath":"/home/engine/project/src/injection.js","messages":[{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'cookie' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":3,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":11},{"ruleId":"complexity","severity":1,"message":"Async function 'main' has a complexity of 38. Maximum allowed is 20.","line":28,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":28,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"let extId;\nlet isFirefox = navigator.userAgent.indexOf('Firefox') > -1;\nlet cookie = null;\nlet otdtoken = null;\n\nif(!window.chrome) window.chrome = {};\nif(!window.chrome.runtime) window.chrome.runtime = {};\nwindow.chrome.runtime.getURL = url => {\n    if(!url.startsWith('/')) url = `/${url}`;\n    return `${isFirefox ? 'moz-extension://' : 'chrome-extension://'}${extId}${url}`;   \n}\nwindow.addEventListener('message', e => {\n    if(e.data.extensionId) {\n        console.log(\"got extensionId\", e.data.extensionId);\n        extId = e.data.extensionId;\n        main();\n    } else if(e.data.cookie) {\n        cookie = e.data.cookie;\n    } else if(e.data.token) {\n        console.log(\"got otdtoken\");\n        otdtoken = e.data.token;\n    }\n});\nwindow.postMessage('extensionId', '*');\nwindow.postMessage('cookie', '*');\nwindow.postMessage('getotdtoken', '*');\n\nasync function main() {\n    let html = await fetch(chrome.runtime.getURL('/files/index.html')).then(r => r.text());\n    document.documentElement.innerHTML = html;\n\n    let [challenge_js, interception_js, vendor_js, bundle_js, bundle_css, twitter_text] =\n        await Promise.allSettled([\n            fetch(chrome.runtime.getURL(\"/src/challenge.js\")).then(r => r.text()),\n            fetch(chrome.runtime.getURL(\"/src/interception.js\")).then(r => r.text()),\n            fetch(chrome.runtime.getURL(\"/files/vendor.js\")).then(r => r.text()),\n            fetch(chrome.runtime.getURL(\"/files/bundle.js\")).then(r => r.text()),\n            fetch(chrome.runtime.getURL(\"/files/bundle.css\")).then(r => r.text()),\n            fetch(chrome.runtime.getURL(\"/files/twitter-text.js\")).then(r => r.text()),\n        ]);\n    if (!localStorage.getItem(\"OTDalwaysUseLocalFiles\")) {\n        const [\n            remote_challenge_js_req,\n            remote_interception_js_req,\n            remote_vendor_js_req,\n            remote_bundle_js_req,\n            remote_bundle_css_req,\n            remote_twitter_text_req,\n        ] = await Promise.allSettled([\n            fetch(\"https://raw.githubusercontent.com/dimdenGD/OldTweetDeck/main/src/challenge.js\"),\n            fetch(\"https://raw.githubusercontent.com/dimdenGD/OldTweetDeck/main/src/interception.js\"),\n            fetch(\"https://raw.githubusercontent.com/dimdenGD/OldTweetDeck/main/files/vendor.js\"),\n            fetch(\"https://raw.githubusercontent.com/dimdenGD/OldTweetDeck/main/files/bundle.js\"),\n            fetch(\"https://raw.githubusercontent.com/dimdenGD/OldTweetDeck/main/files/bundle.css\"),\n            fetch(\"https://raw.githubusercontent.com/dimdenGD/OldTweetDeck/main/files/twitter-text.js\"),\n        ]);\n        \n        if(\n            (remote_challenge_js_req.value && remote_challenge_js_req.value.ok) ||\n            (remote_interception_js_req.value && remote_interception_js_req.value.ok) || \n            (remote_vendor_js_req.value && remote_vendor_js_req.value.ok) ||\n            (remote_bundle_js_req.value && remote_bundle_js_req.value.ok) ||\n            (remote_bundle_css_req.value && remote_bundle_css_req.value.ok) ||\n            (remote_twitter_text_req.value && remote_twitter_text_req.value.ok)\n        ) {\n            const [\n                remote_challenge_js,\n                remote_interception_js,\n                remote_vendor_js,\n                remote_bundle_js,\n                remote_bundle_css,\n                remote_twitter_text,\n            ] = await Promise.allSettled([\n                remote_challenge_js_req.value.text(),\n                remote_interception_js_req.value.text(),\n                remote_vendor_js_req.value.text(),\n                remote_bundle_js_req.value.text(),\n                remote_bundle_css_req.value.text(),\n                remote_twitter_text_req.value.text(),\n            ]);\n\n            if (\n                remote_challenge_js_req.value &&\n                remote_challenge_js_req.value.ok &&\n                remote_challenge_js.status === \"fulfilled\" &&\n                remote_challenge_js.value.length > 30\n            ) {\n                challenge_js = remote_challenge_js;\n                console.log(\"Using remote challenge.js\");\n            }\n\n            if (\n                remote_interception_js_req.value &&\n                remote_interception_js_req.value.ok &&\n                remote_interception_js.status === \"fulfilled\" &&\n                remote_interception_js.value.length > 30\n            ) {\n                interception_js = remote_interception_js;\n                console.log(\"Using remote interception.js\");\n            }\n            if (\n                remote_vendor_js_req.value &&\n                remote_vendor_js_req.value.ok &&\n                remote_vendor_js.status === \"fulfilled\" &&\n                remote_vendor_js.value.length > 30\n            ) {\n                vendor_js = remote_vendor_js;\n                console.log(\"Using remote vendor.js\");\n            }\n            if (\n                remote_bundle_js_req.value &&\n                remote_bundle_js_req.value.ok &&\n                remote_bundle_js.status === \"fulfilled\" &&\n                remote_bundle_js.value.length > 30\n            ) {\n                bundle_js = remote_bundle_js;\n                console.log(\"Using remote bundle.js\");\n            }\n            if (\n                remote_bundle_css_req.value &&\n                remote_bundle_css_req.value.ok &&\n                remote_bundle_css.status === \"fulfilled\" &&\n                remote_bundle_css.value.length > 30\n            ) {\n                bundle_css = remote_bundle_css;\n                console.log(\"Using remote bundle.css\");\n            }\n            if (\n                remote_twitter_text_req.value &&\n                remote_twitter_text_req.value.ok &&\n                remote_twitter_text.status === \"fulfilled\" &&\n                remote_twitter_text.value.length > 30\n            ) {\n                twitter_text = remote_twitter_text;\n                console.log(\"Using remote twitter-text.js\");\n            }\n        }\n    }\n\n    let challenge_js_script = document.createElement(\"script\");\n    challenge_js_script.innerHTML = challenge_js.value.replaceAll('SOLVER_URL', chrome.runtime.getURL(\"solver.html\"));\n    document.head.appendChild(challenge_js_script);\n\n    let interception_js_script = document.createElement(\"script\");\n    interception_js_script.innerHTML = interception_js.value;\n    document.head.appendChild(interception_js_script);\n\n    let bundle_css_style = document.createElement(\"style\");\n    bundle_css_style.innerHTML = bundle_css.value;\n    document.head.appendChild(bundle_css_style);\n\n    let vendor_js_script = document.createElement(\"script\");\n    vendor_js_script.innerHTML = vendor_js.value;\n    document.head.appendChild(vendor_js_script);\n\n    let bundle_js_script = document.createElement(\"script\");\n    bundle_js_script.innerHTML = bundle_js.value;\n    document.head.appendChild(bundle_js_script);\n\n    let twitter_text_script = document.createElement(\"script\");\n    twitter_text_script.innerHTML = twitter_text.value;\n    document.head.appendChild(twitter_text_script);\n\n    (async () => {\n        try {\n            const additionalScripts = await fetch(\"https://oldtd.org/api/scripts\", {\n                headers: otdtoken ? {\n                    Authorization: `Bearer ${otdtoken}`\n                } : undefined\n            }).then(r => r.json());\n            for(let script of additionalScripts) {\n                let scriptSource = await fetch(`https://oldtd.org/api/scripts/${script}`, {\n                    headers: otdtoken ? {\n                        Authorization: `Bearer ${otdtoken}`\n                    } : undefined\n                }).then(r => r.text());\n                let scriptElement = document.createElement(\"script\");\n                scriptElement.innerHTML = scriptSource;\n                document.head.appendChild(scriptElement);\n            }\n        } catch(e) {\n            console.error(e);\n        }\n    })();\n\n    let int = setTimeout(function() {\n        let badBody = document.querySelector('body:not(#injected-body)');\n        if (badBody) {\n            let badHead = document.querySelector('head:not(#injected-head)');\n            clearInterval(int);\n            if(badHead) badHead.remove();\n            badBody.remove(); \n        }\n    }, 200);\n    setTimeout(() => clearInterval(int), 10000);\n\n    let injInt;\n    function injectAccount() {\n        if(!document.querySelector('a[data-title=\"Accounts\"]')) return;\n        clearInterval(injInt);\n\n        let accountsBtn = document.querySelector('a[data-title=\"Accounts\"]');\n        accountsBtn.addEventListener(\"click\", function() {\n            console.log(\"setting account cookie\");\n            chrome.runtime.sendMessage({ action: \"setcookie\" }); \n        });\n    }\n    setInterval(injectAccount, 1000);\n};","usedDeprecatedRules":[]},{"filePath":"/home/engine/project/src/interception.js","messages":[{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'exportState' is defined but never used. Allowed unused vars must match /^_/u.","line":58,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":58,"endColumn":21,"suggestions":[{"messageId":"removeVar","data":{"varName":"exportState"},"fix":{"range":[1496,1851],"text":""},"desc":"Remove unused variable 'exportState'."}]},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'importState' is defined but never used. Allowed unused vars must match /^_/u.","line":70,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":70,"endColumn":21,"suggestions":[{"messageId":"removeVar","data":{"varName":"importState"},"fix":{"range":[1853,2906],"text":""},"desc":"Remove unused variable 'importState'."}]},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":90,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":90,"endColumn":22},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'updateFollows' is defined but never used. Allowed unused vars must match /^_/u.","line":144,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":144,"endColumn":23,"suggestions":[{"messageId":"removeVar","data":{"varName":"updateFollows"},"fix":{"range":[4583,5448],"text":""},"desc":"Remove unused variable 'updateFollows'."}]},{"ruleId":"max-statements","severity":1,"message":"Function 'parseTweet' has too many statements (204). Maximum allowed is 50.","line":189,"column":1,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":497,"endColumn":2},{"ruleId":"complexity","severity":1,"message":"Function 'parseTweet' has a complexity of 204. Maximum allowed is 20.","line":189,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":189,"endColumn":20},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":280,"column":21,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":283,"endColumn":22},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":284,"column":21,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":286,"endColumn":22},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":287,"column":21,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":289,"endColumn":22},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":290,"column":21,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":292,"endColumn":22},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":293,"column":21,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":295,"endColumn":22},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":296,"column":21,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":298,"endColumn":22},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":299,"column":21,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":301,"endColumn":22},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":302,"column":21,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":304,"endColumn":22},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":305,"column":21,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":307,"endColumn":22},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":308,"column":21,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":310,"endColumn":22},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":312,"column":21,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":315,"endColumn":22},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":413,"column":21,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":458,"endColumn":22},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (6). Maximum allowed is 4.","line":419,"column":25,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":422,"endColumn":26},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (6). Maximum allowed is 4.","line":423,"column":25,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":425,"endColumn":26},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (6). Maximum allowed is 4.","line":426,"column":25,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":428,"endColumn":26},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (6). Maximum allowed is 4.","line":429,"column":25,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":431,"endColumn":26},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (6). Maximum allowed is 4.","line":432,"column":25,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":434,"endColumn":26},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (6). Maximum allowed is 4.","line":435,"column":25,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":437,"endColumn":26},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (6). Maximum allowed is 4.","line":438,"column":25,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":440,"endColumn":26},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (6). Maximum allowed is 4.","line":441,"column":25,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":443,"endColumn":26},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (6). Maximum allowed is 4.","line":444,"column":25,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":446,"endColumn":26},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (6). Maximum allowed is 4.","line":447,"column":25,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":449,"endColumn":26},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (6). Maximum allowed is 4.","line":450,"column":25,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":453,"endColumn":26},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (6). Maximum allowed is 4.","line":455,"column":25,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":457,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'TD' is not defined.","line":500,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":500,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'TD' is not defined.","line":501,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":501,"endColumn":25},{"ruleId":"complexity","severity":1,"message":"Function 'extractAssignedJSON' has a complexity of 28. Maximum allowed is 20.","line":515,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":515,"endColumn":29},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'extractAssignedJSON' is defined but never used. Allowed unused vars must match /^_/u.","line":515,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":515,"endColumn":29,"suggestions":[{"messageId":"removeVar","data":{"varName":"extractAssignedJSON"},"fix":{"range":[23556,27165],"text":""},"desc":"Remove unused variable 'extractAssignedJSON'."}]},{"ruleId":"max-statements","severity":1,"message":"Function 'repairCommonJSONIssues' has too many statements (55). Maximum allowed is 50.","line":591,"column":5,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":649,"endColumn":6},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'counter' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":684,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":684,"endColumn":12},{"ruleId":"complexity","severity":1,"message":"Method 'afterRequest' has a complexity of 41. Maximum allowed is 20.","line":758,"column":9,"nodeType":"ArrowFunctionExpression","messageId":"complex","endLine":758,"endColumn":23},{"ruleId":"max-statements","severity":1,"message":"Method 'afterRequest' has too many statements (62). Maximum allowed is 50.","line":758,"column":23,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":881,"endColumn":10},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":809,"column":29,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":809,"endColumn":50},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":810,"column":29,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":815,"endColumn":42},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":816,"column":29,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":816,"endColumn":81},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":817,"column":29,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":830,"endColumn":30},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (6). Maximum allowed is 4.","line":826,"column":33,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":829,"endColumn":34},{"ruleId":"complexity","severity":1,"message":"Method 'afterRequest' has a complexity of 24. Maximum allowed is 20.","line":948,"column":9,"nodeType":"ArrowFunctionExpression","messageId":"complex","endLine":948,"endColumn":23},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":979,"column":29,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":979,"endColumn":50},{"ruleId":"complexity","severity":1,"message":"Method 'afterRequest' has a complexity of 32. Maximum allowed is 20.","line":1116,"column":9,"nodeType":"ArrowFunctionExpression","messageId":"complex","endLine":1116,"endColumn":23},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":1148,"column":29,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":1150,"endColumn":30},{"ruleId":"complexity","severity":1,"message":"Method 'afterRequest' has a complexity of 21. Maximum allowed is 20.","line":1262,"column":9,"nodeType":"ArrowFunctionExpression","messageId":"complex","endLine":1262,"endColumn":23},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":1294,"column":29,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":1296,"endColumn":30},{"ruleId":"complexity","severity":1,"message":"Method 'afterRequest' has a complexity of 45. Maximum allowed is 20.","line":1349,"column":9,"nodeType":"ArrowFunctionExpression","messageId":"complex","endLine":1349,"endColumn":23},{"ruleId":"max-statements","severity":1,"message":"Method 'afterRequest' has too many statements (73). Maximum allowed is 50.","line":1349,"column":23,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":1503,"endColumn":10},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":1366,"column":29,"nodeType":"SwitchStatement","messageId":"tooDeeply","endLine":1475,"endColumn":30},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (6). Maximum allowed is 4.","line":1377,"column":37,"nodeType":"ForOfStatement","messageId":"tooDeeply","endLine":1409,"endColumn":38},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (7). Maximum allowed is 4.","line":1378,"column":41,"nodeType":"ForOfStatement","messageId":"tooDeeply","endLine":1408,"endColumn":42},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (8). Maximum allowed is 4.","line":1382,"column":45,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":1382,"endColumn":74},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (8). Maximum allowed is 4.","line":1384,"column":45,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":1384,"endColumn":89},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (8). Maximum allowed is 4.","line":1388,"column":45,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":1391,"endColumn":46},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (6). Maximum allowed is 4.","line":1417,"column":37,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":1417,"endColumn":57},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (6). Maximum allowed is 4.","line":1422,"column":37,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":1422,"endColumn":81},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (6). Maximum allowed is 4.","line":1425,"column":37,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":1428,"endColumn":38},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (6). Maximum allowed is 4.","line":1448,"column":37,"nodeType":"ForOfStatement","messageId":"tooDeeply","endLine":1466,"endColumn":38},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (7). Maximum allowed is 4.","line":1450,"column":41,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":1450,"endColumn":60},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (7). Maximum allowed is 4.","line":1452,"column":41,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":1452,"endColumn":85},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":1477,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":1477,"endColumn":31},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'sortIndex' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1539,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":1539,"endColumn":40,"suggestions":[{"messageId":"removeVar","data":{"varName":"sortIndex"},"fix":{"range":[74212,74246],"text":""},"desc":"Remove unused variable 'sortIndex'."}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":1549,"column":33,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":1549,"endColumn":53},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":1552,"column":33,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":1555,"endColumn":34},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'xhr' is defined but never used. Allowed unused args must match /^_/u.","line":1712,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":1712,"endColumn":27,"suggestions":[{"messageId":"removeVar","data":{"varName":"xhr"},"fix":{"range":[81652,81655],"text":""},"desc":"Remove unused variable 'xhr'."}]},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'body' is defined but never used. Allowed unused args must match /^_/u.","line":2059,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":2059,"endColumn":35,"suggestions":[{"messageId":"removeVar","data":{"varName":"body"},"fix":{"range":[97241,97247],"text":""},"desc":"Remove unused variable 'body'."}]},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'body' is defined but never used. Allowed unused args must match /^_/u.","line":2113,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":2113,"endColumn":35,"suggestions":[{"messageId":"removeVar","data":{"varName":"body"},"fix":{"range":[99247,99253],"text":""},"desc":"Remove unused variable 'body'."}]},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'body' is defined but never used. Allowed unused args must match /^_/u.","line":2307,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":2307,"endColumn":35,"suggestions":[{"messageId":"removeVar","data":{"varName":"body"},"fix":{"range":[108224,108230],"text":""},"desc":"Remove unused variable 'body'."}]},{"ruleId":"complexity","severity":1,"message":"Method 'afterRequest' has a complexity of 63. Maximum allowed is 20.","line":2340,"column":9,"nodeType":"ArrowFunctionExpression","messageId":"complex","endLine":2340,"endColumn":23},{"ruleId":"max-statements","severity":1,"message":"Method 'afterRequest' has too many statements (70). Maximum allowed is 50.","line":2340,"column":23,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":2453,"endColumn":10},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":2436,"column":29,"nodeType":"ForOfStatement","messageId":"tooDeeply","endLine":2446,"endColumn":30},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (6). Maximum allowed is 4.","line":2437,"column":33,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":2445,"endColumn":34},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'xhr' is defined but never used. Allowed unused args must match /^_/u.","line":2459,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":2459,"endColumn":28,"suggestions":[{"messageId":"removeVar","data":{"varName":"xhr"},"fix":{"range":[115977,115980],"text":""},"desc":"Remove unused variable 'xhr'."}]},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'dest' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":2539,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":2539,"endColumn":21,"suggestions":[{"messageId":"removeVar","data":{"varName":"dest"},"fix":{"range":[119260,119290],"text":""},"desc":"Remove unused variable 'dest'."}]},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'xhr' is defined but never used. Allowed unused args must match /^_/u.","line":2567,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":2567,"endColumn":27,"suggestions":[{"messageId":"removeVar","data":{"varName":"xhr"},"fix":{"range":[120474,120477],"text":""},"desc":"Remove unused variable 'xhr'."}]},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'xhr' is defined but never used. Allowed unused args must match /^_/u.","line":2634,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":2634,"endColumn":27,"suggestions":[{"messageId":"removeVar","data":{"varName":"xhr"},"fix":{"range":[122983,122986],"text":""},"desc":"Remove unused variable 'xhr'."}]},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'xhr' is defined but never used. Allowed unused args must match /^_/u.","line":2700,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":2700,"endColumn":27,"suggestions":[{"messageId":"removeVar","data":{"varName":"xhr"},"fix":{"range":[124955,124958],"text":""},"desc":"Remove unused variable 'xhr'."}]},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'xhr' is defined but never used. Allowed unused args must match /^_/u.","line":2710,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":2710,"endColumn":27,"suggestions":[{"messageId":"removeVar","data":{"varName":"xhr"},"fix":{"range":[128124,128127],"text":""},"desc":"Remove unused variable 'xhr'."}]},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'xhr' is defined but never used. Allowed unused args must match /^_/u.","line":2720,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":2720,"endColumn":27,"suggestions":[{"messageId":"removeVar","data":{"varName":"xhr"},"fix":{"range":[128439,128442],"text":""},"desc":"Remove unused variable 'xhr'."}]},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'xhr' is defined but never used. Allowed unused args must match /^_/u.","line":2730,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":2730,"endColumn":27,"suggestions":[{"messageId":"removeVar","data":{"varName":"xhr"},"fix":{"range":[129249,129252],"text":""},"desc":"Remove unused variable 'xhr'."}]},{"ruleId":"no-global-assign","severity":2,"message":"Read-only global 'XMLHttpRequest' should not be modified.","line":2737,"column":1,"nodeType":"Identifier","messageId":"globalShouldNotBeModified","endLine":2737,"endColumn":15},{"ruleId":"complexity","severity":1,"message":"Async method 'send' has a complexity of 24. Maximum allowed is 20.","line":2775,"column":9,"nodeType":"FunctionExpression","messageId":"complex","endLine":2775,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'solveChallenge' is not defined.","line":2802,"column":80,"nodeType":"Identifier","messageId":"undef","endLine":2802,"endColumn":94},{"ruleId":"no-unsafe-negation","severity":2,"message":"Unexpected negating the left operand of 'in' operator.","line":2833,"column":17,"nodeType":"BinaryExpression","messageId":"unexpected","endLine":2833,"endColumn":21,"suggestions":[{"messageId":"suggestNegatedExpression","data":{"operator":"in"},"fix":{"range":[133407,133417],"text":"(key in xhr)"},"desc":"Negate 'in' expression instead of its left operand. This changes the current behavior."},{"messageId":"suggestParenthesisedNegation","fix":{"range":[133406,133410],"text":"(!key)"},"desc":"Wrap negation in '()' to make the intention explicit. This preserves the current behavior."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":82,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const PUBLIC_TOKENS = [\n    \"Bearer AAAAAAAAAAAAAAAAAAAAANRILgAAAAAAnNwIzUejRCOuH5E6I8xnZz4puTs%3D1Zv7ttfk8LF81IUq16cHjhLTvJu4FA33AGWWjCpTnA\",\n];\nconst NEW_API = `https://${location.hostname}/i/api/graphql`;\nconst cursors = {};\nconst OTD_INIT_TIME = Date.now();\n\nconst generateID = () => {\n    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n}\n\nlet verifiedUser;\nif(localStorage.OTDverifiedUser) {\n    try {\n        verifiedUser = JSON.parse(localStorage.OTDverifiedUser);\n    } catch(e) {\n        console.warn(`Error parsing OTDverifiedUser.`, e);\n        verifiedUser = null;\n    }\n}\nlet feeds;\nif(localStorage.OTDfeeds) {\n    try {\n        feeds = JSON.parse(localStorage.OTDfeeds);\n    } catch(e) {\n        console.warn(`Error parsing OTDfeeds.`, e);\n        feeds = {};\n    }\n}\nlet columns;\nif(localStorage.OTDcolumns) {\n    try {\n        columns = JSON.parse(localStorage.OTDcolumns);\n    } catch(e) {\n        console.warn(`Error parsing OTDcolumns.`, e);\n        columns = {};\n    }\n}\nlet settings;\nif(localStorage.OTDsettings) {\n    try {\n        settings = JSON.parse(localStorage.OTDsettings);\n    } catch(e) {\n        console.warn(`Error parsing OTDsettings.`, e);\n        settings = null;\n    }\n}\nlet seenNotifications = [];\nlet seenHomeTweets = {};\nlet timings = {\n    home: {},\n    list: {},\n    user: {},\n    search: {},\n}\nlet refreshInterval = localStorage.OTDrefreshInterval ? parseInt(localStorage.OTDrefreshInterval) : 35000;\n\nfunction exportState() {\n\tconst a = document.createElement('a');\n    a.href = URL.createObjectURL(new Blob([JSON.stringify({\n        feeds, \n        columns,\n        settings,\n        columnIds: localStorage.OTDcolumnIds ? JSON.parse(localStorage.OTDcolumnIds) : []\n    })], {type: 'application/json'}));\n    a.download = 'OTDState.json';\n    a.click();\n}\n\nfunction importState() {\n    const input = document.createElement('input');\n    input.type = 'file';\n    input.accept = '.json';\n    input.onchange = async () => {\n        const file = input.files[0];\n        if(!file) return;\n        const reader = new FileReader();\n        reader.onload = async (e) => {\n            const text = e.target.result;\n            try {\n                const data = JSON.parse(text);\n                if(!data.feeds || !data.columns || !data.settings || !data.columnIds) {\n                    throw new Error(\"Invalid file\");\n                }\n                localStorage.OTDfeeds = JSON.stringify(data.feeds);\n                localStorage.OTDcolumns = JSON.stringify(data.columns);\n                localStorage.OTDsettings = JSON.stringify(data.settings);\n                localStorage.OTDcolumnIds = JSON.stringify(data.columnIds);\n                location.reload();\n            } catch(e) {\n                alert(\"Error parsing file\");\n            }\n        };\n        reader.readAsText(file);\n    };\n    input.click();\n}\n\nfunction cleanUp() {\n    let ids = localStorage.OTDcolumnIds ? JSON.parse(localStorage.OTDcolumnIds) : [];\n    for(let columnId in columns) {\n        if(!ids.includes(columnId)) {\n            delete columns[columnId];\n        }\n    }\n    localStorage.OTDcolumns = JSON.stringify(columns);\n    for(let id in feeds) {\n        if(!localStorage.OTDcolumns.includes(id)) {\n            delete feeds[id];\n        }\n    }\n    localStorage.OTDfeeds = JSON.stringify(feeds);\n}\n\nfunction getFollows(id = getCurrentUserId(), cursor = -1, count = 5000) {\n\treturn new Promise(function (resolve, reject) {\n\t\tvar xhr = new XMLHttpRequest();\n\t\txhr.open(\"GET\", `https://api.${location.hostname}/1.1/friends/ids.json?user_id=${id}&cursor=${cursor}&stringify_ids=true&count=${count}`, true);\n\t\txhr.setRequestHeader(\"X-Twitter-Active-User\", \"yes\");\n\t\txhr.setRequestHeader(\"X-Twitter-Auth-Type\", \"OAuth2Session\");\n\t\txhr.setRequestHeader(\"X-Twitter-Client-Language\", \"en\");\n\t\txhr.setRequestHeader(\"Authorization\", \"Bearer AAAAAAAAAAAAAAAAAAAAANRILgAAAAAAnNwIzUejRCOuH5E6I8xnZz4puTs%3D1Zv7ttfk8LF81IUq16cHjhLTvJu4FA33AGWWjCpTnA\");\n\t\txhr.setRequestHeader(\"X-Csrf-Token\", (function () {\n\t\t\tvar csrf = document.cookie.match(/(?:^|;\\s*)ct0=([0-9a-f]+)\\s*(?:;|$)/);\n\t\t\treturn csrf ? csrf[1] : \"\";\n\t\t})());\n\t\txhr.withCredentials = true;\n\n\t\txhr.onreadystatechange = function () {\n\t\t\tif (xhr.readyState === 4 && xhr.status === 200) {\n\t\t\t\tresolve(JSON.parse(xhr.responseText));\n\t\t\t} else if (xhr.readyState === 4 && xhr.status !== 200) {\n                reject(xhr);\n            }\n\t\t};\n\t\t\n\t\txhr.send();\n\t});\n}\n\nlet followsData = JSON.parse(localStorage.OTDfollowsData || \"{}\");\n\nlet updatingFollows = false;\nfunction updateFollows(id = getCurrentUserId()) {\n    if(followsData[id] && followsData[id].lastUpdate && Date.now() - +followsData[id].lastUpdate < 1000 * 60 * 60 * 6) return;\n    if(updatingFollows) return;\n    updatingFollows = true;\n\n    if(!followsData[id]) followsData[id] = {};\n    let newfollows = [];\n    let cursor = -1;\n    let count = 5000;\n    let i = 0;\n    let get = async () => {\n        let res = await getFollows(id, cursor, count);\n        newfollows = newfollows.concat(res.ids);\n        if(res.next_cursor_str === \"0\" || i++ > 10) {\n            followsData[id].lastUpdate = Date.now();\n            followsData[id].data = newfollows;\n            localStorage.OTDfollowsData = JSON.stringify(followsData);\n            updatingFollows = false;\n            return;\n        }\n        cursor = res.next_cursor_str;\n        get();\n    };\n\n    get();\n}\n\n// setTimeout(updateFollows, 1000);\n// setInterval(updateFollows, 1000 * 60);\n\nfunction parseNoteTweet(result) {\n    let text, entities;\n    if (result.note_tweet.note_tweet_results.result) {\n        text = result.note_tweet.note_tweet_results.result.text;\n        entities = result.note_tweet.note_tweet_results.result.entity_set;\n        if (result.note_tweet.note_tweet_results.result.richtext?.richtext_tags.length) {\n            entities.richtext = result.note_tweet.note_tweet_results.result.richtext.richtext_tags; // logically, richtext is an entity, right?\n        }\n    } else {\n        text = result.note_tweet.note_tweet_results.text;\n        entities = result.note_tweet.note_tweet_results.entity_set;\n    }\n    return { text, entities };\n}\n\nfunction parseTweet(res) {\n    try {\n\n        if (typeof res !== \"object\") return;\n        if (res.limitedActionResults) {\n            let limitation = res.limitedActionResults.limited_actions.find((l) => l.action === \"Reply\");\n            if (limitation) {\n                res.tweet.legacy.limited_actions_text = limitation.prompt\n                    ? limitation.prompt.subtext.text\n                    : \"This tweet has limitations to who can reply.\";\n            }\n            res = res.tweet;\n        }\n        if (!res.legacy && res.tweet) res = res.tweet;\n        let tweet = res.legacy;\n        if (!res.core || !tweet) return;\n        if(!tweet.id) {\n            tweet.id = +tweet.id_str;\n        }\n        let result = res.core.user_results.result;\n        tweet.conversation_id = +tweet.conversation_id_str;\n        tweet.text = tweet.full_text;\n        tweet.user = result.legacy;\n        tweet.user.id = +tweet.user_id_str;\n        tweet.user.id_str = tweet.user_id_str;\n        if (result.is_blue_verified) {\n            tweet.user.verified = true;\n            tweet.user.verified_type = \"Blue\";\n        }\n        if(!tweet.user.profile_image_url && result?.avatar?.image_url) {\n            tweet.user.profile_image_url = result.avatar.image_url;\n            tweet.user.profile_image_url_https = tweet.user.profile_image_url.replace(\"http://\", \"https://\");\n        }\n        if(!tweet.user.profile_image_url && tweet.user.profile_image_url_https) {\n            tweet.user.profile_image_url = tweet.user.profile_image_url_https.replace(\"https://\", \"http://\");\n        }\n        if(!tweet.user.name && result?.core?.name) {\n            tweet.user.name = result.core.name;\n        }\n        if(!tweet.user.screen_name && result?.core?.screen_name) {\n            tweet.user.screen_name = result.core.screen_name;\n        }\n        if(!tweet.user.created_at && result?.core?.created_at) {\n            tweet.user.created_at = result.core.created_at;\n        }\n        if(result?.relationship_perspectives?.muting) {\n            tweet.user.muting = true;\n        }\n        if(result?.relationship_perspectives?.blocking) {\n            tweet.user.blocking = true;\n        }\n        if(result?.privacy?.protected) {\n            tweet.user.protected = true;\n        }\n        if(result?.location?.location) {\n            tweet.user.location = res.core.user_results.result.location.location;\n        }\n        if(result?.verification?.verified) {\n            tweet.user.verified = true;\n        }\n\n        if (tweet.retweeted_status_result?.result) {\n            let result = tweet.retweeted_status_result.result;\n            if (result.limitedActionResults) {\n                let limitation = result.limitedActionResults.limited_actions.find(\n                    (l) => l.action === \"Reply\"\n                );\n                if (limitation) {\n                    result.tweet.legacy.limited_actions_text = limitation.prompt\n                        ? limitation.prompt.subtext.text\n                        : \"This tweet has limitations to who can reply.\";\n                }\n                result = result.tweet;\n            }\n            if (\n                result.quoted_status_result &&\n                result.quoted_status_result.result &&\n                result.quoted_status_result.result.legacy &&\n                result.quoted_status_result.result.core &&\n                result.quoted_status_result.result.core.user_results.result.legacy\n            ) {\n                result.legacy.quoted_status = result.quoted_status_result.result.legacy;\n                result.legacy.quoted_status.id = +result.legacy.quoted_status.id_str;\n                result.legacy.quoted_status.text = result.legacy.quoted_status.full_text;\n                result.legacy.quoted_status.conversation_id = +result.legacy.quoted_status.conversation_id_str;\n                if (result.legacy.quoted_status) {\n                    result.legacy.quoted_status.user =\n                        result.quoted_status_result.result.core.user_results.result.legacy;\n                    result.legacy.quoted_status.user.id_str = result.legacy.quoted_status.user_id_str;\n                    result.legacy.quoted_status.user.id = +result.legacy.quoted_status.user_id_str;\n                    let user_result = result?.quoted_status_result?.result?.core?.user_results?.result;\n                    if(!result.legacy.quoted_status.user.profile_image_url && user_result?.avatar?.image_url) {\n                        result.legacy.quoted_status.user.profile_image_url = user_result.avatar.image_url;\n                        result.legacy.quoted_status.user.profile_image_url_https = result.legacy.quoted_status.user.profile_image_url.replace(\"http://\", \"https://\");\n                    }\n                    if(!result.legacy.quoted_status.user.profile_image_url && result.legacy.quoted_status.user.profile_image_url_https) {\n                        result.legacy.quoted_status.user.profile_image_url = result.legacy.quoted_status.user.profile_image_url_https.replace(\"https://\", \"http://\");\n                    }\n                    if(!result.legacy.quoted_status.user.name && user_result?.core?.name) {\n                        result.legacy.quoted_status.user.name = user_result.core.name;\n                    }\n                    if(!result.legacy.quoted_status.user.screen_name && user_result?.core?.screen_name) {\n                        result.legacy.quoted_status.user.screen_name = user_result.core.screen_name;\n                    }\n                    if(!result.legacy.quoted_status.user.created_at && user_result?.core?.created_at) {\n                        result.legacy.quoted_status.user.created_at = user_result.core.created_at;\n                    }\n                    if(user_result?.relationship_perspectives?.muting) {\n                        result.legacy.quoted_status.user.muting = true;\n                    }\n                    if(user_result?.relationship_perspectives?.blocking) {\n                        result.legacy.quoted_status.user.blocking = true;\n                    }\n                    if(user_result?.privacy?.protected) {\n                        result.legacy.quoted_status.user.protected = true;\n                    }\n                    if(user_result?.location?.location) {\n                        result.legacy.quoted_status.user.location = user_result.location.location;\n                    }\n                    if(user_result?.verification?.verified) {\n                        result.legacy.quoted_status.user.verified = true;\n                    }\n                    \n                    if (user_result.is_blue_verified) {\n                        result.legacy.quoted_status.user.verified = true;\n                        result.legacy.quoted_status.user.verified_type = \"Blue\";\n                    }\n                } else {\n                    console.warn(\"No retweeted quoted status\", result);\n                }\n            }\n            tweet.retweeted_status = result.legacy;\n            if (tweet.retweeted_status && result.core.user_results.result.legacy) {\n                let user_result = result?.core?.user_results?.result;\n                tweet.retweeted_status.text = tweet.retweeted_status.full_text;\n                tweet.retweeted_status.id = +tweet.retweeted_status.id_str;\n                tweet.retweeted_status.conversation_id = +tweet.retweeted_status.conversation_id_str;\n                tweet.retweeted_status.user = user_result.legacy;\n                tweet.retweeted_status.user.id_str = tweet.retweeted_status.user_id_str;\n                tweet.retweeted_status.user.id = +tweet.retweeted_status.user_id_str;\n                if(!tweet.retweeted_status.user.profile_image_url && user_result?.avatar?.image_url) {\n                    tweet.retweeted_status.user.profile_image_url = user_result.avatar.image_url;\n                    tweet.retweeted_status.user.profile_image_url_https = tweet.retweeted_status.user.profile_image_url.replace(\"http://\", \"https://\");\n                } \n                if(!tweet.retweeted_status.user.profile_image_url && tweet.retweeted_status.user.profile_image_url_https) {\n                    tweet.retweeted_status.user.profile_image_url = tweet.retweeted_status.user.profile_image_url_https.replace(\"https://\", \"http://\");\n                }\n                if(!tweet.retweeted_status.user.name && user_result?.core?.name) {\n                    tweet.retweeted_status.user.name = user_result.core.name;\n                }\n                if(!tweet.retweeted_status.user.screen_name && user_result?.core?.screen_name) {\n                    tweet.retweeted_status.user.screen_name = user_result.core.screen_name;\n                }\n                if(!tweet.retweeted_status.user.created_at && user_result?.core?.created_at) {\n                    tweet.retweeted_status.user.created_at = user_result.core.created_at;\n                }\n                if(user_result?.relationship_perspectives?.muting) {\n                    tweet.retweeted_status.user.muting = true;\n                }\n                if(user_result?.relationship_perspectives?.blocking) {\n                    tweet.retweeted_status.user.blocking = true;\n                }\n                if(user_result?.privacy?.protected) {\n                    tweet.retweeted_status.user.protected = true;\n                }\n                if(user_result?.location?.location) {\n                    tweet.retweeted_status.user.location = result.core.user_results.result.location.location;\n                }\n                if(user_result?.verification?.verified) {\n                    tweet.retweeted_status.user.verified = true;\n                }\n\n                if (result.core.user_results.result.is_blue_verified) {\n                    tweet.retweeted_status.user.verified = true;\n                    tweet.retweeted_status.user.verified_type = \"Blue\";\n                }\n                tweet.retweeted_status.ext = {};\n                if (result.views) {\n                    tweet.retweeted_status.ext.views = { r: { ok: { count: +result.views.count } } };\n                }\n                if (res.card && res.card.legacy && res.card.legacy.binding_values) {\n                    tweet.retweeted_status.card = res.card.legacy;\n                }\n            } else {\n                console.warn(\"No retweeted status\", result);\n            }\n            if (result.note_tweet && result.note_tweet.note_tweet_results && localStorage.OTDenableAutoExpand === \"1\") {\n                let note = parseNoteTweet(result);\n                tweet.retweeted_status.full_text = note.text;\n                tweet.retweeted_status.entities = note.entities;\n                tweet.retweeted_status.display_text_range = undefined; // no text range for long tweets\n            }\n        }\n    \n        if (res.quoted_status_result) {\n            tweet.quoted_status_result = res.quoted_status_result;\n        }\n        if (res.note_tweet && res.note_tweet.note_tweet_results) {\n            let note = parseNoteTweet(res);\n            tweet.full_text = note.text;\n            tweet.entities = note.entities;\n            tweet.display_text_range = undefined; // no text range for long tweets\n        }\n        if (tweet.quoted_status_result && tweet.quoted_status_result.result) {\n            let result = tweet.quoted_status_result.result;\n            if (!result.core && result.tweet) result = result.tweet;\n            if (result.limitedActionResults) {\n                let limitation = result.limitedActionResults.limited_actions.find(\n                    (l) => l.action === \"Reply\"\n                );\n                if (limitation) {\n                    result.tweet.legacy.limited_actions_text = limitation.prompt\n                        ? limitation.prompt.subtext.text\n                        : \"This tweet has limitations to who can reply.\";\n                }\n                result = result.tweet;\n            }\n            if(result && result.legacy) {\n                tweet.quoted_status = result.legacy;\n                tweet.quoted_status.id = +tweet.quoted_status.id_str;\n                tweet.quoted_status.conversation_id = +tweet.quoted_status.conversation_id_str;\n                tweet.quoted_status.text = tweet.quoted_status.full_text;\n                if (tweet.quoted_status) {\n                    tweet.quoted_status.user = result.core.user_results.result.legacy;\n                    if (!tweet.quoted_status.user) {\n                        delete tweet.quoted_status;\n                    } else {\n                        tweet.quoted_status.user.id_str = tweet.quoted_status.user_id_str;\n                        tweet.quoted_status.user.id = +tweet.quoted_status.user_id_str;\n                        let user_result = result?.core?.user_results?.result;\n                        if(!tweet.quoted_status.user.profile_image_url && user_result?.avatar?.image_url) {\n                            tweet.quoted_status.user.profile_image_url = user_result.avatar.image_url;\n                            tweet.quoted_status.user.profile_image_url_https = tweet.quoted_status.user.profile_image_url.replace(\"http://\", \"https://\");\n                        }\n                        if(!tweet.quoted_status.user.profile_image_url && tweet.quoted_status.user.profile_image_url_https) {\n                            tweet.quoted_status.user.profile_image_url = tweet.quoted_status.user.profile_image_url_https.replace(\"https://\", \"http://\");\n                        }\n                        if(!tweet.quoted_status.user.name && user_result?.core?.name) {\n                            tweet.quoted_status.user.name = user_result.core.name;\n                        }\n                        if(!tweet.quoted_status.user.screen_name && user_result?.core?.screen_name) {\n                            tweet.quoted_status.user.screen_name = user_result.core.screen_name;\n                        }\n                        if(!tweet.quoted_status.user.created_at && user_result?.core?.created_at) {\n                            tweet.quoted_status.user.created_at = user_result.core.created_at;\n                        }\n                        if(user_result?.relationship_perspectives?.muting) {\n                            tweet.quoted_status.user.muting = true;\n                        }\n                        if(user_result?.relationship_perspectives?.blocking) {\n                            tweet.quoted_status.user.blocking = true;\n                        }\n                        if(user_result?.privacy?.protected) {\n                            tweet.quoted_status.user.protected = true;\n                        }\n                        if(user_result?.location?.location) {\n                            tweet.quoted_status.user.location = user_result.location.location;\n                        }\n                        if(user_result?.verification?.verified) {\n                            tweet.quoted_status.user.verified = true;\n                        }\n                        if (user_result.is_blue_verified) {\n                            tweet.quoted_status.user.verified = true;\n                            tweet.quoted_status.user.verified_type = \"Blue\";\n                        }\n                        tweet.quoted_status.ext = {};\n                        if (result.views) {\n                            tweet.quoted_status.ext.views = { r: { ok: { count: +result.views.count } } };\n                        }\n                    }\n                } else {\n                    console.warn(\"No quoted status\", result);\n                }\n            }\n        }\n        if (res.card && res.card.legacy) {\n            tweet.card = res.card.legacy;\n            let bvo = {};\n            for (let i = 0; i < tweet.card.binding_values.length; i++) {\n                let bv = tweet.card.binding_values[i];\n                bvo[bv.key] = bv.value;\n            }\n            tweet.card.binding_values = bvo;\n        }\n        if (res.views) {\n            if (!tweet.ext) tweet.ext = {};\n            tweet.ext.views = { r: { ok: { count: +res.views.count } } };\n        }\n        if (res.source) {\n            tweet.source = res.source;\n        }\n        if (res.birdwatch_pivot) {\n            // community notes\n            tweet.birdwatch = res.birdwatch_pivot;\n        }\n    \n        if (tweet.favorited && tweet.favorite_count === 0) {\n            tweet.favorite_count = 1;\n        }\n        if (tweet.retweeted && tweet.retweet_count === 0) {\n            tweet.retweet_count = 1;\n        }\n    \n        return tweet;\n    } catch (e) {\n        console.error('error parsing tweet', e, res);\n        throw new Error('error parsing tweet');\n    }\n}\n\nfunction getCurrentUserId() {\n    let accounts = TD.storage.accountController.getAll();\n    let screen_name = TD.storage.accountController.getUserIdentifier();\n    let account = accounts.find((account) => account.state.username === screen_name);\n    return account?.state?.userId ?? verifiedUser?.id_str ?? localStorage.twitterAccountID;\n}\n\nfunction generateParams(features, variables, fieldToggles) {\n    let params = new URLSearchParams();\n    params.append(\"variables\", JSON.stringify(variables));\n    params.append(\"features\", JSON.stringify(features));\n    if (fieldToggles) params.append(\"fieldToggles\", JSON.stringify(fieldToggles));\n\n    return params.toString();\n}\n\nfunction extractAssignedJSON(html, varName = \"window.__INITIAL_STATE__\") {\n    const assignPos = html.indexOf(varName);\n    if (assignPos === -1) {\n        console.error(html);\n        throw new Error(`Variable ${varName} not found`);\n    }\n  \n    let i = assignPos + varName.length;\n    while (i < html.length && /\\s/.test(html[i])) i++;\n    if (html[i] !== '=') {\n      i = html.indexOf('=', i);\n      if (i === -1) throw new Error(`Assignment for ${varName} not found`);\n    }\n    i++; // skip '='\n    while (i < html.length && /\\s/.test(html[i])) i++;\n  \n    const opener = html[i];\n    if (opener !== '{' && opener !== '[') {\n      throw new Error(`Expected JSON object/array after ${varName} = ...`);\n    }\n    const closer = opener === '{' ? '}' : ']';\n  \n    let depth = 0, inStr = false, quote = null, escaped = false;\n    const start = i;\n    for (; i < html.length; i++) {\n      const ch = html[i];\n  \n      if (inStr) {\n        if (escaped) {\n          escaped = false;\n        } else if (ch === '\\\\') {\n          escaped = true;\n        } else if (ch === quote) {\n          inStr = false;\n          quote = null;\n        }\n        continue;\n      }\n      if (ch === '\"' || ch === \"'\") {\n        inStr = true;\n        quote = ch;\n        continue;\n      }\n      if (ch === opener) depth++;\n      else if (ch === closer) {\n        depth--;\n        if (depth === 0) break;\n      }\n    }\n    if (depth !== 0) throw new Error(`Unterminated JSON for ${varName}`);\n  \n    let jsonText = html.slice(start, i + 1);\n  \n    let j = i + 1;\n    while (j < html.length && /\\s/.test(html[j])) j++;\n    if (html[j] === ';') j++;\n  \n    try {\n      return JSON.parse(stripBOM(jsonText));\n    } catch (e) {\n      const repaired = repairCommonJSONIssues(jsonText);\n      try {\n        return JSON.parse(repaired);\n      } catch (e2) {\n        const ctx = repaired.slice(0, 1200);\n        throw new Error(\n          `Found assignment, but JSON.parse failed twice. First: ${e.message}. Second: ${e2.message}. ` +\n          `Sample of repaired text start:\\n${ctx}`\n        );\n      }\n    }\n  \n    function stripBOM(s) {\n      return s.charCodeAt(0) === 0xFEFF ? s.slice(1) : s;\n    }\n  \n    function repairCommonJSONIssues(s) {\n      s = stripBOM(s);\n  \n      let out = '';\n      let inStr = false;\n      let quote = null;\n      let escaped = false;\n  \n      for (let k = 0; k < s.length; k++) {\n        let ch = s[k];\n  \n        if (!inStr) {\n          if (ch === '\"' || ch === \"'\") {\n            inStr = true;\n            quote = ch;\n            out += ch;\n            continue;\n          }\n          out += ch;\n          continue;\n        }\n  \n        if (escaped) {\n          escaped = false;\n          out += ch;\n          continue;\n        }\n        if (ch === '\\\\') {\n          escaped = true;\n          out += ch;\n          continue;\n        }\n        if (ch === quote) {\n          inStr = false;\n          quote = null;\n          out += ch;\n          continue;\n        }\n  \n        const code = ch.charCodeAt(0);\n  \n        if (code === 0x2028) { out += '\\\\u2028'; continue; }\n        if (code === 0x2029) { out += '\\\\u2029'; continue; }\n  \n        if (code >= 0x00 && code <= 0x1F) {\n          if (ch === '\\n') { out += '\\\\n'; continue; }\n          if (ch === '\\r') { out += '\\\\r'; continue; }\n          if (ch === '\\t') { out += '\\\\t'; continue; }\n          if (ch === '\\b') { out += '\\\\b'; continue; }\n          if (ch === '\\f') { out += '\\\\f'; continue; }\n          out += '\\\\u' + code.toString(16).padStart(4, '0');\n          continue;\n        }\n  \n        out += ch;\n      }\n  \n      return out;\n    }\n}\nfunction formatTwitterStyle(date) {\n    const days = [\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\"];\n    const months = [\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"];\n  \n    const day = days[date.getUTCDay()];\n    const month = months[date.getUTCMonth()];\n    const dayNum = String(date.getUTCDate()).padStart(2, \"0\");\n    const hours = String(date.getUTCHours()).padStart(2, \"0\");\n    const mins = String(date.getUTCMinutes()).padStart(2, \"0\");\n    const secs = String(date.getUTCSeconds()).padStart(2, \"0\");\n    const year = date.getUTCFullYear();\n  \n    return `${day} ${month} ${dayNum} ${hours}:${mins}:${secs} +0000 ${year}`;\n}\n\nfunction emulateResponse(xhr) {\n    xhr._status = 200;\n    xhr._readyState = 4;\n    xhr.responseHeaderOverride = {\n        \"content-type\": () => \"application/json\"\n    }\n    const loadEvent = new ProgressEvent('load');\n    loadEvent.lengthComputable = true;\n    loadEvent.loaded = 1;\n    loadEvent.total = 1;\n\n    if(xhr.onload) xhr.onload(loadEvent);\n    if(xhr.onloadend) xhr.onloadend(loadEvent);\n\n    const readyStateEvent = new Event('readystatechange');\n    if(xhr.onreadystatechange) xhr.onreadystatechange(readyStateEvent);\n}\n\nlet counter = 0;\nlet bookmarkTimes = {};\nconst OriginalXHR = XMLHttpRequest;\nconst proxyRoutes = [\n    // Home timeline\n    {\n        path: \"/1.1/statuses/home_timeline.json\",\n        method: \"GET\",\n        beforeRequest: (xhr) => {\n            try {\n                let url = new URL(xhr.modUrl);\n                let params = new URLSearchParams(url.search);\n                let variables = {\"count\":40,\"includePromotedContent\":true,\"latestControlAvailable\":true};\n                let features = {\"rweb_video_screen_enabled\":false,\"profile_label_improvements_pcf_label_in_post_enabled\":true,\"responsive_web_profile_redirect_enabled\":false,\"rweb_tipjar_consumption_enabled\":true,\"verified_phone_label_enabled\":false,\"creator_subscriptions_tweet_preview_api_enabled\":true,\"responsive_web_graphql_timeline_navigation_enabled\":true,\"responsive_web_graphql_skip_user_profile_image_extensions_enabled\":false,\"premium_content_api_read_enabled\":false,\"communities_web_enable_tweet_community_results_fetch\":true,\"c9s_tweet_anatomy_moderator_badge_enabled\":true,\"responsive_web_grok_analyze_button_fetch_trends_enabled\":false,\"responsive_web_grok_analyze_post_followups_enabled\":true,\"responsive_web_jetfuel_frame\":true,\"responsive_web_grok_share_attachment_enabled\":true,\"articles_preview_enabled\":true,\"responsive_web_edit_tweet_api_enabled\":true,\"graphql_is_translatable_rweb_tweet_is_translatable_enabled\":true,\"view_counts_everywhere_api_enabled\":true,\"longform_notetweets_consumption_enabled\":true,\"responsive_web_twitter_article_tweet_consumption_enabled\":true,\"tweet_awards_web_tipping_enabled\":false,\"responsive_web_grok_show_grok_translated_post\":false,\"responsive_web_grok_analysis_button_from_backend\":true,\"creator_subscriptions_quote_tweet_preview_enabled\":false,\"freedom_of_speech_not_reach_fetch_enabled\":true,\"standardized_nudges_misinfo\":true,\"tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled\":true,\"longform_notetweets_rich_text_read_enabled\":true,\"longform_notetweets_inline_media_enabled\":true,\"responsive_web_grok_image_annotation_enabled\":true,\"responsive_web_grok_imagine_annotation_enabled\":true,\"responsive_web_grok_community_note_auto_translation_is_enabled\":false,\"responsive_web_enhance_cards_enabled\":false};\n\n                let max_id = params.get(\"max_id\");\n                let since_id = params.get(\"since_id\");\n                let user_id = xhr.modReqHeaders[\"x-act-as-user-id\"] ?? params.get(\"user_id\") ?? getCurrentUserId();\n                if(params.get(\"user_id\")) {\n                    xhr.storage.user_id = params.get(\"user_id\");\n                }\n                if (max_id) {\n                    let bn = BigInt(params.get(\"max_id\"));\n                    bn += BigInt(1);\n                    if (cursors[`home-${user_id}-${bn}`]) {\n                        variables.cursor = cursors[`home-${user_id}-${bn}`];\n                        xhr.storage.cursor = true;\n                    }\n                }\n                if (since_id) {\n                    let bn = BigInt(params.get(\"since_id\"));\n                    if (cursors[`home-${user_id}-${bn}-top`]) {\n                        variables.cursor = cursors[`home-${user_id}-${bn}-top`];\n                        xhr.storage.cursor = true;\n                        xhr.storage.since_id = since_id;\n                    }\n                }\n                xhr.modUrl = `${NEW_API}/cWF3cqWadLlIXA6KJWhcew/HomeLatestTimeline?${generateParams(\n                    features,\n                    variables\n                )}`;\n            } catch (e) {\n                console.error(e);\n            }\n        },\n        openHandler: (xhr, method, url, async, username, password) => {\n            let user_id = xhr.modReqHeaders[\"x-act-as-user-id\"] ?? xhr.storage.user_id ?? getCurrentUserId();\n            xhr.storage.user_id = user_id;\n            if(!timings.home[user_id]) {\n                timings.home[user_id] = 0;\n            }\n            if(Date.now() - timings.home[user_id] < refreshInterval && xhr.storage.cursor && Math.random() > 0.6) {\n                xhr.storage.cancelled = true;\n            } else {\n                xhr.open(method, url, async, username, password);\n                timings.home[user_id] = Date.now();\n            }\n        },\n        sendHandler: (xhr, data) => {\n            if(xhr.storage.cancelled) {\n                emulateResponse(xhr);\n            } else {\n                xhr.send(data);\n            }\n        },\n        beforeSendHeaders: (xhr) => {\n            xhr.storage.user_id = xhr.modReqHeaders[\"x-act-as-user-id\"] ?? getCurrentUserId();\n            xhr.modReqHeaders[\"Content-Type\"] = \"application/json\";\n            xhr.modReqHeaders[\"X-Twitter-Active-User\"] = \"yes\";\n            xhr.modReqHeaders[\"X-Twitter-Client-Language\"] = \"en\";\n            xhr.modReqHeaders[\"Authorization\"] = PUBLIC_TOKENS[0];\n            delete xhr.modReqHeaders[\"X-Twitter-Client-Version\"];\n            // updateFollows(xhr.storage.user_id);\n        },\n        afterRequest: (xhr) => {\n            if(xhr.storage.cancelled) {\n                return [];\n            }\n            if(xhr.storage.data) {\n                return xhr.storage.data;\n            }\n            let data;\n            try {\n                data = JSON.parse(xhr.responseText);\n            } catch (e) {\n                console.error(e);\n                return [];\n            }\n            if (data.errors && data.errors[0]) {\n                return [];\n            }\n            let instructions = data.data.home.home_timeline_urt.instructions;\n            let entries = instructions.find((i) => i.type === \"TimelineAddEntries\");\n            if (!entries) {\n                return [];\n            }\n            entries = entries.entries;\n            let tweets = [];\n            for (let e of entries) {\n                // thats a lot of trash https://lune.dimden.dev/0bf524e52eb.png\n                if (e.entryId.startsWith(\"tweet-\")) {\n                    let res = e.content.itemContent.tweet_results.result;\n                    let tweet = parseTweet(res);\n                    if (!tweet) continue;\n                    if (\n                        tweet.source &&\n                        (tweet.source.includes(\"Twitter for Advertisers\") ||\n                            tweet.source.includes(\"advertiser-interface\"))\n                    )\n                        continue;\n                    if (tweet.user.blocking || tweet.user.muting) continue;\n\n                    tweets.push(tweet);\n                } else if (e.entryId.startsWith(\"home-conversation-\")) {\n                    let items = e.content.items;\n\n                    let pushTweets = [];\n                    for (let i = 0; i < items.length; i++) {\n                        let item = items[i];\n                        if (\n                            item.entryId.includes(\"-tweet-\") &&\n                            !item.entryId.includes(\"promoted\")\n                        ) {\n                            let res = item.item.itemContent.tweet_results.result;\n                            let tweet = parseTweet(res);\n                            if (!tweet) continue;\n                            if (\n                                tweet.source &&\n                                (tweet.source.includes(\"Twitter for Advertisers\") ||\n                                    tweet.source.includes(\"advertiser-interface\"))\n                            )\n                                continue;\n                            if (tweet.user.blocking || tweet.user.muting) break;\n                            if (item.item.feedbackInfo) {\n                                tweet.feedback = item.item.feedbackInfo.feedbackKeys\n                                    .map(\n                                        (f) =>\n                                            data.data.home.home_timeline_urt.responseObjects.feedbackActions.find(\n                                                (a) => a.key === f\n                                            ).value\n                                    )\n                                    .filter((f) => f);\n                                if (tweet.feedback) {\n                                    tweet.feedbackMetadata =\n                                        item.item.feedbackInfo.feedbackMetadata;\n                                }\n                            }\n                            pushTweets.push(tweet);\n                        }\n                    }\n                    if(!seenHomeTweets[xhr.storage.user_id]) {\n                        seenHomeTweets[xhr.storage.user_id] = [];\n                    }\n                    for(let tweet of pushTweets) {\n                        if(xhr.storage.since_id && seenHomeTweets[xhr.storage.user_id].includes(tweet.id_str)) continue;\n                        seenHomeTweets[xhr.storage.user_id].push(tweet.id_str);\n                        tweets.push(tweet);\n                    }\n                }\n            }\n\n            if (tweets.length === 0) return tweets;\n\n            // i didn't know they return tweets unsorted???\n            tweets.sort(\n                (a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime()\n            );\n            if(!seenHomeTweets[xhr.storage.user_id]) {\n                seenHomeTweets[xhr.storage.user_id] = [];\n            }\n            for(let tweet of tweets) {\n                if(seenHomeTweets[xhr.storage.user_id].includes(tweet.id_str)) continue;\n                seenHomeTweets[xhr.storage.user_id].push(tweet.id_str);\n            }\n\n            let bottomCursor = entries.find(\n                (e) =>\n                    e.entryId.startsWith(\"sq-cursor-bottom-\") ||\n                    e.entryId.startsWith(\"cursor-bottom-\")\n            );\n            if (bottomCursor) {\n                cursors[`home-${xhr.storage.user_id}-${tweets[tweets.length - 1].id_str}`] =\n                    bottomCursor.content.value;\n            }\n            let topCursor = entries.find(\n                (e) =>\n                    e.entryId.startsWith(\"sq-cursor-top-\") ||\n                    e.entryId.startsWith(\"cursor-top-\")\n            )?.content?.value;\n            if (topCursor) {\n                if(tweets[0]) cursors[`home-${xhr.storage.user_id}-${tweets[0].id_str}-top`] = topCursor;\n                if(tweets[1]) cursors[`home-${xhr.storage.user_id}-${tweets[1].id_str}-top`] = topCursor;\n            }\n\n            xhr.storage.data = tweets;\n\n            return tweets;\n        },\n    },\n    // List timeline\n    {\n        path: \"/1.1/lists/statuses.json\",\n        method: \"GET\",\n        beforeRequest: (xhr) => {\n            try {\n                let url = new URL(xhr.modUrl);\n                let params = new URLSearchParams(url.search);\n                let variables = { count: 40, includePromotedContent: false };\n                let features = {\"rweb_video_screen_enabled\":false,\"payments_enabled\":false,\"profile_label_improvements_pcf_label_in_post_enabled\":true,\"rweb_tipjar_consumption_enabled\":true,\"verified_phone_label_enabled\":false,\"creator_subscriptions_tweet_preview_api_enabled\":true,\"responsive_web_graphql_timeline_navigation_enabled\":true,\"responsive_web_graphql_skip_user_profile_image_extensions_enabled\":false,\"premium_content_api_read_enabled\":false,\"communities_web_enable_tweet_community_results_fetch\":true,\"c9s_tweet_anatomy_moderator_badge_enabled\":true,\"responsive_web_grok_analyze_button_fetch_trends_enabled\":false,\"responsive_web_grok_analyze_post_followups_enabled\":true,\"responsive_web_jetfuel_frame\":true,\"responsive_web_grok_share_attachment_enabled\":true,\"articles_preview_enabled\":true,\"responsive_web_edit_tweet_api_enabled\":true,\"graphql_is_translatable_rweb_tweet_is_translatable_enabled\":true,\"view_counts_everywhere_api_enabled\":true,\"longform_notetweets_consumption_enabled\":true,\"responsive_web_twitter_article_tweet_consumption_enabled\":true,\"tweet_awards_web_tipping_enabled\":false,\"responsive_web_grok_show_grok_translated_post\":false,\"responsive_web_grok_analysis_button_from_backend\":false,\"creator_subscriptions_quote_tweet_preview_enabled\":false,\"freedom_of_speech_not_reach_fetch_enabled\":true,\"standardized_nudges_misinfo\":true,\"tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled\":true,\"longform_notetweets_rich_text_read_enabled\":true,\"longform_notetweets_inline_media_enabled\":true,\"responsive_web_grok_image_annotation_enabled\":true,\"responsive_web_grok_community_note_auto_translation_is_enabled\":false,\"responsive_web_enhance_cards_enabled\":false};\n\n                let list_id = params.get(\"list_id\");\n                let max_id = params.get(\"max_id\");\n                let since_id = params.get(\"since_id\");\n                if (max_id) {\n                    let bn = BigInt(params.get(\"max_id\"));\n                    bn += BigInt(1);\n                    if (cursors[`list-${list_id}-${bn}`]) {\n                        variables.cursor = cursors[`list-${list_id}-${bn}`];\n                        xhr.storage.cursor = true;\n                    }\n                }\n                if (since_id) {\n                    let bn = BigInt(params.get(\"since_id\"));\n                    if (cursors[`list-${list_id}-${bn}-top`]) {\n                        variables.cursor = cursors[`list-${list_id}-${bn}-top`];\n                        xhr.storage.cursor = true;\n                    }\n                }\n                variables.listId = list_id;\n                xhr.storage.list_id = list_id;\n                xhr.modUrl = `${NEW_API}/l411pL-GRg-AKo_a2rmYjg/ListLatestTweetsTimeline?${generateParams(\n                    features,\n                    variables\n                )}`;\n            } catch (e) {\n                console.error(e);\n            }\n        },\n        beforeSendHeaders: (xhr) => {\n            xhr.modReqHeaders[\"Content-Type\"] = \"application/json\";\n            xhr.modReqHeaders[\"X-Twitter-Active-User\"] = \"yes\";\n            xhr.modReqHeaders[\"X-Twitter-Client-Language\"] = \"en\";\n            xhr.modReqHeaders[\"Authorization\"] = PUBLIC_TOKENS[0];\n            delete xhr.modReqHeaders[\"X-Twitter-Client-Version\"];\n        },\n        openHandler: (xhr, method, url, async, username, password) => {\n            const list_id = xhr.storage.list_id;\n            if(!timings.list[list_id]) {\n                timings.list[list_id] = 0;\n            }\n            if(Date.now() - timings.list[list_id] < refreshInterval && xhr.storage.cursor) {\n                xhr.storage.cancelled = true;\n            } else {\n                xhr.open(method, url, async, username, password);\n                timings.list[list_id] = Date.now();\n            }\n        },\n        sendHandler: (xhr, data) => {\n            if(xhr.storage.cancelled) {\n                emulateResponse(xhr);\n            } else {\n                xhr.send(data);\n            }\n        },\n        afterRequest: (xhr) => {\n            if(xhr.storage.cancelled) {\n                return [];\n            }\n            let data;\n            try {\n                data = JSON.parse(xhr.responseText);\n            } catch (e) {\n                console.error(e);\n                return [];\n            }\n            let list = data?.data?.list?.tweets_timeline?.timeline?.instructions?.find(\n                (i) => i.type === \"TimelineAddEntries\"\n            );\n            if (!list) return [];\n            list = list.entries;\n            let tweets = [];\n            for (let e of list) {\n                if (e.entryId.startsWith(\"tweet-\")) {\n                    let res = e.content.itemContent.tweet_results.result;\n                    let tweet = parseTweet(res);\n                    if (tweet) {\n                        tweets.push(tweet);\n                    }\n                } else if (e.entryId.startsWith(\"list-conversation-\")) {\n                    let lt = e.content.items;\n                    for (let i = 0; i < lt.length; i++) {\n                        let t = lt[i];\n                        if (t.entryId.includes(\"-tweet-\")) {\n                            let res = t.item.itemContent.tweet_results.result;\n                            let tweet = parseTweet(res);\n                            if (!tweet) continue;\n                            tweets.push(tweet);\n                        }\n                    }\n                }\n            }\n\n            if (tweets.length === 0) return tweets;\n\n            tweets = tweets.filter(t => !t.user.muting && !t.user.blocking);\n\n            // i didn't know they return tweets unsorted???\n            tweets.sort(\n                (a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime()\n            )\n\n            let bottomCursor = list.find(\n                (e) =>\n                    e.entryId.startsWith(\"sq-cursor-bottom-\") ||\n                    e.entryId.startsWith(\"cursor-bottom-\")\n            );\n            if (bottomCursor) {\n                cursors[`list-${xhr.storage.list_id}-${tweets[tweets.length - 1].id_str}`] =\n                    bottomCursor.content.value;\n            }\n            let topCursor = list.find(\n                (e) =>\n                    e.entryId.startsWith(\"sq-cursor-top-\") ||\n                    e.entryId.startsWith(\"cursor-top-\")\n            )?.content?.value;\n            if (topCursor) {\n                if(tweets[0]) cursors[`list-${xhr.storage.list_id}-${tweets[0].id_str}-top`] = topCursor;\n                if(tweets[1]) cursors[`list-${xhr.storage.list_id}-${tweets[1].id_str}-top`] = topCursor;\n            }\n\n            return tweets;\n        },\n    },\n    // User timeline\n    {\n        path: \"/1.1/statuses/user_timeline.json\",\n        method: \"GET\",\n        beforeRequest: (xhr) => {\n            try {\n                let url = new URL(xhr.modUrl);\n                let params = new URLSearchParams(url.search);\n                let user_id = params.get(\"user_id\");\n                let variables = {\n                    count: 20,\n                    includePromotedContent: false,\n                    withQuickPromoteEligibilityTweetFields: false,\n                    withVoice: true,\n                    withV2Timeline: true,\n                };\n                let features = {\n                    rweb_lists_timeline_redesign_enabled: false,\n                    responsive_web_graphql_exclude_directive_enabled: true,\n                    verified_phone_label_enabled: false,\n                    creator_subscriptions_tweet_preview_api_enabled: true,\n                    responsive_web_graphql_timeline_navigation_enabled: true,\n                    responsive_web_graphql_skip_user_profile_image_extensions_enabled: false,\n                    tweetypie_unmention_optimization_enabled: true,\n                    responsive_web_edit_tweet_api_enabled: true,\n                    graphql_is_translatable_rweb_tweet_is_translatable_enabled: true,\n                    view_counts_everywhere_api_enabled: true,\n                    longform_notetweets_consumption_enabled: true,\n                    responsive_web_twitter_article_tweet_consumption_enabled: false,\n                    tweet_awards_web_tipping_enabled: false,\n                    freedom_of_speech_not_reach_fetch_enabled: true,\n                    standardized_nudges_misinfo: true,\n                    tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled: true,\n                    longform_notetweets_rich_text_read_enabled: true,\n                    longform_notetweets_inline_media_enabled: true,\n                    responsive_web_media_download_video_enabled: false,\n                    responsive_web_enhance_cards_enabled: false,\n                };\n\n                if (!user_id) {\n                    variables.userId = getCurrentUserId();\n                } else {\n                    variables.userId = user_id;\n                }\n                let since_id = params.get(\"since_id\");\n                let max_id = params.get(\"max_id\");\n                if (max_id) {\n                    let bn = BigInt(params.get(\"max_id\"));\n                    bn += BigInt(1);\n                    if (cursors[`${variables.userId}-${bn}`]) {\n                        variables.cursor = cursors[`${variables.userId}-${bn}`];\n                        xhr.storage.cursor = true;\n                    }\n                }\n                if (since_id) {\n                    let bn = BigInt(params.get(\"since_id\"));\n                    if (cursors[`${variables.userId}-${bn}-top`]) {\n                        variables.cursor = cursors[`${variables.userId}-${bn}-top`];\n                        xhr.storage.cursor = true;\n                    }\n                }\n                xhr.storage.user_id = variables.userId;\n\n                xhr.modUrl = `${NEW_API}/wxoVeDnl0mP7VLhe6mTOdg/UserTweetsAndReplies?${generateParams(\n                    features,\n                    variables\n                )}`;\n            } catch (e) {\n                console.error(e);\n            }\n        },\n        beforeSendHeaders: (xhr) => {\n            xhr.modReqHeaders[\"Content-Type\"] = \"application/json\";\n            xhr.modReqHeaders[\"X-Twitter-Active-User\"] = \"yes\";\n            xhr.modReqHeaders[\"X-Twitter-Client-Language\"] = \"en\";\n            xhr.modReqHeaders[\"Authorization\"] =\n                PUBLIC_TOKENS[0];\n            delete xhr.modReqHeaders[\"X-Twitter-Client-Version\"];\n            // delete xhr.modReqHeaders[\"x-act-as-user-id\"];\n        },\n        openHandler: (xhr, method, url, async, username, password) => {\n            const user_id = xhr.storage.user_id;\n            if(!timings.user[user_id]) {\n                timings.user[user_id] = 0;\n            }\n            if(Date.now() - timings.user[user_id] < refreshInterval && xhr.storage.cursor) {\n                xhr.storage.cancelled = true;\n            } else {\n                xhr.open(method, url, async, username, password);\n                timings.user[user_id] = Date.now();\n            }\n        },\n        sendHandler: (xhr, data) => {\n            if(xhr.storage.cancelled) {\n                emulateResponse(xhr);\n            } else {\n                xhr.send(data);\n            }\n        },\n        afterRequest: (xhr) => {\n            if(xhr.storage.cancelled) {\n                return [];\n            }\n            let data;\n            try {\n                data = JSON.parse(xhr.responseText);\n            } catch (e) {\n                console.error(e);\n                return [];\n            }\n            let instructions = data?.data?.user?.result?.timeline_v2?.timeline?.instructions;\n            let entries = instructions?.find((e) => e.type === \"TimelineAddEntries\");\n            if (!entries) {\n                return [];\n            }\n            entries = entries.entries;\n            let tweets = [];\n            for (let entry of entries) {\n                if (entry.entryId.startsWith(\"tweet-\")) {\n                    let result = entry.content.itemContent.tweet_results.result;\n                    let tweet = parseTweet(result);\n                    if (tweet) {\n                        tweets.push(tweet);\n                    }\n                } else if (entry.entryId.startsWith(\"profile-conversation-\")) {\n                    let items = entry.content.items;\n                    for (let i = 0; i < items.length; i++) {\n                        let item = items[i];\n                        let result = item.item.itemContent.tweet_results.result;\n                        if (item.entryId.includes(\"-tweet-\")) {\n                            let tweet = parseTweet(result);\n                            if (tweet && tweet.user.id_str === xhr.storage.user_id) {\n                                tweets.push(tweet);\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (tweets.length === 0) return tweets;\n\n            // i didn't know they return tweets unsorted???\n            tweets.sort(\n                (a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime()\n            );\n\n            let bottomCursor = entries.find(\n                (e) =>\n                    e.entryId.startsWith(\"sq-cursor-bottom-\") ||\n                    e.entryId.startsWith(\"cursor-bottom-\")\n            ).content.value;\n            if (bottomCursor) {\n                cursors[`${xhr.storage.user_id}-${tweets[tweets.length - 1].id_str}`] = bottomCursor;\n            }\n            let topCursor = entries.find(\n                (e) =>\n                    e.entryId.startsWith(\"sq-cursor-top-\") ||\n                    e.entryId.startsWith(\"cursor-top-\")\n            )?.content?.value;\n            if (topCursor) {\n                if(tweets[0]) cursors[`${xhr.storage.user_id}-${tweets[0].id_str}-top`] = topCursor;\n                if(tweets[1]) cursors[`${xhr.storage.user_id}-${tweets[1].id_str}-top`] = topCursor;\n            }\n\n            let pinEntry = instructions.find((e) => e.type === \"TimelinePinEntry\");\n            if (\n                pinEntry &&\n                pinEntry.entry &&\n                pinEntry.entry.content &&\n                pinEntry.entry.content.itemContent\n            ) {\n                let result = pinEntry.entry.content.itemContent.tweet_results.result;\n                let pinnedTweet = parseTweet(result);\n                if (pinnedTweet) {\n                    let tweetTimes = tweets.map((t) => [\n                        t.id_str,\n                        new Date(t.created_at).getTime(),\n                    ]);\n                    tweetTimes.push([\n                        pinnedTweet.id_str,\n                        new Date(pinnedTweet.created_at).getTime(),\n                    ]);\n                    tweetTimes.sort((a, b) => b[1] - a[1]);\n                    let index = tweetTimes.findIndex((t) => t[0] === pinnedTweet.id_str);\n                    if (index !== tweets.length) {\n                        tweets.splice(index, 0, pinnedTweet);\n                    }\n                }\n            }\n\n            return tweets;\n        },\n    },\n    // Bookmarks timeline\n    {\n        path: \"/1.1/statuses/bookmarks.json\",\n        method: \"GET\",\n        beforeRequest: (xhr) => {\n            try {\n                let url = new URL(xhr.modUrl);\n                let params = new URLSearchParams(url.search);\n                let variables = {\n                    \"count\": 40,\n                    \"includePromotedContent\":false\n                };\n                let features = {\"graphql_timeline_v2_bookmark_timeline\":true,\"blue_business_profile_image_shape_enabled\":true,\"responsive_web_graphql_exclude_directive_enabled\":true,\"verified_phone_label_enabled\":false,\"responsive_web_graphql_timeline_navigation_enabled\":true,\"responsive_web_graphql_skip_user_profile_image_extensions_enabled\":false,\"tweetypie_unmention_optimization_enabled\":true,\"vibe_api_enabled\":true,\"responsive_web_edit_tweet_api_enabled\":true,\"graphql_is_translatable_rweb_tweet_is_translatable_enabled\":true,\"view_counts_everywhere_api_enabled\":true,\"longform_notetweets_consumption_enabled\":true,\"tweet_awards_web_tipping_enabled\":false,\"freedom_of_speech_not_reach_fetch_enabled\":true,\"standardized_nudges_misinfo\":true,\"tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled\":false,\"interactive_text_enabled\":true,\"responsive_web_text_conversations_enabled\":false,\"longform_notetweets_rich_text_read_enabled\":true,\"responsive_web_enhance_cards_enabled\":false};\n\n                let max_id = params.get(\"max_id\");\n                if (max_id) {\n                    let bn = BigInt(params.get(\"max_id\"));\n                    bn += BigInt(1);\n                    if (cursors[`bookmarks-${bn}`]) {\n                        variables.cursor = cursors[`bookmarks-${bn}`];\n                    }\n                    if(bookmarkTimes[`${bn}`]) {\n                        xhr.storage.time = bookmarkTimes[`${bn}`];\n                    }\n                }\n\n                xhr.modUrl = `${NEW_API}/3OjEFzT2VjX-X7w4KYBJRg/Bookmarks?${generateParams(\n                    features,\n                    variables\n                )}`;\n            } catch (e) {\n                console.error(e);\n            }\n        },\n        beforeSendHeaders: (xhr) => {\n            xhr.modReqHeaders[\"Content-Type\"] = \"application/json\";\n            xhr.modReqHeaders[\"X-Twitter-Active-User\"] = \"yes\";\n            xhr.modReqHeaders[\"X-Twitter-Client-Language\"] = \"en\";\n            xhr.modReqHeaders[\"Authorization\"] =\n                PUBLIC_TOKENS[0];\n            delete xhr.modReqHeaders[\"X-Twitter-Client-Version\"];\n            // delete xhr.modReqHeaders[\"x-act-as-user-id\"];\n        },\n        // artificially slow down, because theres an invisible rate limit that gets hit after a few hours\n        responseHeaderOverride: {\n            \"x-rate-limit-limit\": (value) => {\n                return Math.floor(+value/5);\n            },\n            \"x-rate-limit-remaining\": (value) => {\n                return Math.floor(+value/5);\n            },\n        },\n        afterRequest: (xhr) => {\n            let data;\n            try {\n                data = JSON.parse(xhr.responseText);\n            } catch (e) {\n                console.error(e);\n                return [];\n            }\n            // if (data.errors && data.errors[0]) {\n            //     return [];\n            // }\n            let instructions = data?.data?.bookmark_timeline_v2?.timeline?.instructions;\n            let entries = instructions?.find((e) => e.type === \"TimelineAddEntries\");\n            if (!entries) {\n                return [];\n            }\n            entries = entries.entries;\n            let tweets = [];\n            for (let entry of entries) {\n                if (entry.entryId.startsWith(\"tweet-\")) {\n                    let result = entry.content.itemContent.tweet_results.result;\n                    let tweet = parseTweet(result);\n                    if (tweet) {\n                        tweets.push(tweet);\n                    }\n                } else if (entry.entryId.startsWith(\"profile-conversation-\")) {\n                    let items = entry.content.items;\n                    for (let i = 0; i < items.length; i++) {\n                        let item = items[i];\n                        let result = item.item.itemContent.tweet_results.result;\n                        if (item.entryId.includes(\"-tweet-\")) {\n                            let tweet = parseTweet(result);\n                            if (tweet && tweet.user.id_str === xhr.storage.user_id) {\n                                tweets.push(tweet);\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (tweets.length === 0) return tweets;\n\n            for(let i = 0; i < tweets.length; i++) {\n                const tweet = tweets[i];\n                tweet.receiveTime = bookmarkTimes[tweet.id_str] ?? ((xhr.storage.time ?? Date.now()) - i);\n                bookmarkTimes[tweet.id_str] = tweet.receiveTime;\n            }\n\n            let cursor = entries.find(\n                (e) =>\n                    e.entryId.startsWith(\"sq-cursor-bottom-\") ||\n                    e.entryId.startsWith(\"cursor-bottom-\")\n            ).content.value;\n            if (cursor) {\n                cursors[`bookmarks-${tweets[tweets.length - 1].id_str}`] = cursor;\n            }\n\n            return tweets;\n        },\n    },\n    // Notifications column\n    {\n        path: \"/1.1/activity/about_me.json\",\n        method: \"GET\",\n        beforeRequest: (xhr) => {\n            const params = new URLSearchParams(xhr.modUrl);\n            const since_id = params.get(\"since_id\");\n            const max_id = params.get(\"max_id\");\n            const user_id = xhr.modReqHeaders[\"x-act-as-user-id\"] ?? params.get(\"user_id\") ?? getCurrentUserId();\n            let cursor;\n            if(since_id && cursors[`notifications-${user_id}-top`]) {\n                cursor = cursors[`notifications-${user_id}-top`];\n            } else if(max_id && cursors[`notifications-${user_id}-bottom`]) {\n                cursor = cursors[`notifications-${user_id}-bottom`];\n            }\n\n            xhr.modUrl = `https://${location.hostname}/i/api/2/notifications/all.json?include_profile_interstitial_type=1&include_blocking=1&include_blocked_by=1&include_followed_by=1&include_want_retweets=1&include_mute_edge=1&include_can_dm=1&include_can_media_tag=1&include_ext_has_nft_avatar=1&include_ext_is_blue_verified=1&include_ext_verified_type=1&include_ext_profile_image_shape=1&skip_status=1&cards_platform=Web-12&include_cards=1&include_ext_alt_text=true&include_ext_limited_action_results=true&include_quote_count=true&include_reply_count=1&tweet_mode=extended&include_ext_views=true&include_entities=true&include_user_entities=true&include_ext_media_color=true&include_ext_media_availability=true&include_ext_sensitive_media_warning=true&include_ext_trusted_friends_metadata=true&send_error_codes=true&simple_quoted_tweet=true&count=20&requestContext=launch&ext=mediaStats%2ChighlightedLabel%2ChasNftAvatar%2CvoiceInfo%2CbirdwatchPivot%2CsuperFollowMetadata%2CunmentionInfo%2CeditControl${cursor ? `&cursor=${cursor}` : ''}`;\n        },\n        beforeSendHeaders: (xhr) => {\n            xhr.storage.user_id = xhr.modReqHeaders[\"x-act-as-user-id\"] ?? getCurrentUserId();\n            xhr.modReqHeaders[\"Content-Type\"] = \"application/json\";\n            xhr.modReqHeaders[\"X-Twitter-Active-User\"] = \"yes\";\n            xhr.modReqHeaders[\"X-Twitter-Client-Language\"] = navigator.language.split(\"-\")[0];\n            xhr.modReqHeaders[\"Authorization\"] =\n                PUBLIC_TOKENS[0];\n            delete xhr.modReqHeaders[\"X-Twitter-Client-Version\"];\n        },\n        afterRequest: (xhr) => {\n            if(xhr.storage.notifications) {\n                return xhr.storage.notifications;\n            }\n            try {\n                const response = JSON.parse(xhr.responseText);\n                const entries = response.timeline.instructions.find((i) => i.addEntries).addEntries.entries;\n                const go = response.globalObjects;\n                const notifications = [];\n                for(let entry of entries) {\n                    try {\n                        if(entry.entryId.startsWith(\"notification-\")) {\n                            const sortIndex = entry.sortIndex;\n                            const item = entry.content.item;\n                            const type = item.clientEventInfo.element;\n                            const notif = item.content.notification;\n    \n                            switch(type) {\n                                case \"users_retweeted_your_retweet\":\n                                case \"users_retweeted_your_tweet\":\n                                case \"user_liked_multiple_tweets\": \n                                case \"users_liked_your_retweet\":\n                                case \"users_liked_your_tweet\": {\n                                    const nf = go.notifications[notif.id];\n                                    const actions = nf.template.aggregateUserActionsV1;\n                                    const users = actions.fromUsers.map(u => u.user.id);\n                                    const tweets = actions.targetObjects.map(t => t.tweet.id);\n                                    let i = 0;\n                                    for(const userId of users) {\n                                        for(const tweetId of tweets) {\n                                            const tweet = go.tweets[tweetId];\n                                            const user = go.users[userId];\n                                            const action = type === \"users_retweeted_your_tweet\" || type === \"users_retweeted_your_retweet\" ? \"retweet\" : \"favorite\";\n                                            if(!tweet || !user) continue;\n                                            const id = `${tweetId}-${userId}-${action}`;\n                                            if(seenNotifications.includes(id)) continue;\n                                            seenNotifications.push(id);\n                                            const notifSortIndex = +sortIndex - (i++);\n                                            tweet.user = go.users[tweet.user_id_str];\n                                            if(tweet.quoted_status_id_str) {\n                                                tweet.quoted_status = go.tweets[tweet.quoted_status_id_str];\n                                                tweet.quoted_status.user = go.users[tweet.quoted_status.user_id_str];\n                                            }\n    \n                                            const sources = [user];\n                                            const targets = [tweet];\n                                            const target_objects = [tweet];\n                                            notifications.push({\n                                                action,\n                                                created_at: formatTwitterStyle(new Date(notifSortIndex)),\n                                                max_position: notifSortIndex+\"\",\n                                                min_position: notifSortIndex+\"\",\n                                                sources,\n                                                sources_size: sources.length,\n                                                target_objects,\n                                                target_objects_size: target_objects.length,\n                                                targets,\n                                                targets_size: targets.length,\n                                            })\n                                        }\n                                    }\n                                    break;\n                                }\n                                case \"user_mentioned_you\":\n                                case \"user_replied_to_your_tweet\": \n                                case \"user_quoted_your_tweet\":{\n                                    const tweetId = item.content.tweet.id;\n                                    const tweet = go.tweets[tweetId];\n                                    if(!tweet) continue;\n                                    tweet.user = go.users[tweet.user_id_str];\n                                    const type = item.clientEventInfo.element === \"user_mentioned_you\" ? \"mention\" : item.clientEventInfo.element === \"user_replied_to_your_tweet\" ? \"reply\" : \"quote\";\n                                    \n                                    const id = `${tweetId}-${tweet.user_id_str}-${type}`;\n                                    if(seenNotifications.includes(id)) continue;\n                                    seenNotifications.push(id);\n    \n                                    if(tweet.quoted_status_id_str) {\n                                        tweet.quoted_status = go.tweets[tweet.quoted_status_id_str];\n                                        tweet.quoted_status.user = go.users[tweet.quoted_status.user_id_str];\n                                    }\n                                    \n                                    notifications.push({\n                                        action: type,\n                                        created_at: formatTwitterStyle(new Date(+sortIndex)),\n                                        max_position: sortIndex+\"\",\n                                        min_position: sortIndex+\"\",\n                                        sources: [tweet.user],\n                                        sources_size: 1,\n                                        target_objects: [tweet],\n                                        target_objects_size: 1,\n                                        targets: [tweet],\n                                        targets_size: 1,\n                                    });\n                                    break;\n                                }\n                                case \"follow_from_recommended_user\":\n                                case \"users_followed_you\": {\n                                    const nf = go.notifications[notif.id];\n                                    const users = nf.template.aggregateUserActionsV1.fromUsers.map(u => u.user.id);\n                                    for(const userId of users) {\n                                        const user = go.users[userId];\n                                        if(!user) continue;\n                                        const id = `${userId}-follow`;\n                                        if(seenNotifications.includes(id)) continue;\n                                        seenNotifications.push(id);\n                                        notifications.push({\n                                            action: \"follow\",\n                                            created_at: formatTwitterStyle(new Date(+sortIndex)),\n                                            max_position: sortIndex+\"\",\n                                            min_position: sortIndex+\"\",\n                                            sources: [user],\n                                            sources_size: 1,\n                                            target_objects: [user],\n                                            target_objects_size: 1,\n                                            targets: [user],\n                                            targets_size: 1\n                                        });\n                                    }\n                                    break;\n                                }\n                                case \"generic_login_notification\":\n                                case \"generic_acid_notification\":\n                                case \"generic_safety_label_added\":\n                                    break;\n                                default:\n                                    console.warn(`Unknown notification type: ${type}`);\n                            }\n                        }\n                    } catch (e) {\n                        console.error(`Error parsing notification`, JSON.stringify(entry));\n                    }\n                }\n                xhr.storage.notifications = notifications;\n                const cursorTop = entries.find(\n                    (e) =>\n                        e.entryId.startsWith(\"sq-cursor-top-\") ||\n                        e.entryId.startsWith(\"cursor-top-\")\n                )?.content?.operation?.cursor?.value;\n                if(cursorTop) {\n                    cursors[`notifications-${xhr.storage.user_id}-top`] = cursorTop;\n                }\n                const cursorBottom = entries.find(\n                    (e) =>\n                        e.entryId.startsWith(\"sq-cursor-bottom-\") ||\n                        e.entryId.startsWith(\"cursor-bottom-\")\n                )?.content?.operation?.cursor?.value;\n                if(cursorBottom) {\n                    cursors[`notifications-${xhr.storage.user_id}-bottom`] = cursorBottom;\n                }\n                return notifications;\n            } catch (e) {\n                console.error(`Error parsing notifications`, e);\n                return [];\n            }\n        },\n    },\n    // Mentions timeline\n    {\n        path: \"/1.1/statuses/mentions_timeline.json\",\n        method: \"GET\",\n        beforeRequest: (xhr) => {\n            const params = new URLSearchParams(xhr.modUrl);\n            const since_id = params.get(\"since_id\");\n            const max_id = params.get(\"max_id\");\n            const user_id = xhr.modReqHeaders[\"x-act-as-user-id\"] ?? params.get(\"user_id\") ?? getCurrentUserId();\n            xhr.storage.user_id = user_id;\n            let cursor;\n            if(since_id && cursors[`mentions-${user_id}-top`]) {\n                cursor = cursors[`mentions-${user_id}-top`];\n            } else if(max_id && cursors[`mentions-${user_id}-bottom`]) {\n                cursor = cursors[`mentions-${user_id}-bottom`];\n            }\n\n            xhr.modUrl = `https://${location.hostname}/i/api/2/notifications/mentions.json?include_profile_interstitial_type=1&include_blocking=1&include_blocked_by=1&include_followed_by=1&include_want_retweets=1&include_mute_edge=1&include_can_dm=1&include_can_media_tag=1&include_ext_has_nft_avatar=1&include_ext_is_blue_verified=1&include_ext_verified_type=1&include_ext_profile_image_shape=1&skip_status=1&cards_platform=Web-12&include_cards=1&include_ext_alt_text=true&include_ext_limited_action_results=true&include_quote_count=true&include_reply_count=1&tweet_mode=extended&include_ext_views=true&include_entities=true&include_user_entities=true&include_ext_media_color=true&include_ext_media_availability=true&include_ext_sensitive_media_warning=true&include_ext_trusted_friends_metadata=true&send_error_codes=true&simple_quoted_tweet=true&count=20&requestContext=launch&ext=mediaStats%2ChighlightedLabel%2ChasNftAvatar%2CvoiceInfo%2CbirdwatchPivot%2CsuperFollowMetadata%2CunmentionInfo%2CeditControl${cursor ? `&cursor=${cursor}` : ''}`;\n        },\n        beforeSendHeaders: (xhr) => {\n            xhr.modReqHeaders[\"Content-Type\"] = \"application/json\";\n            xhr.modReqHeaders[\"X-Twitter-Active-User\"] = \"yes\";\n            xhr.modReqHeaders[\"X-Twitter-Client-Language\"] = \"en\";\n            xhr.modReqHeaders[\"Authorization\"] = PUBLIC_TOKENS[0];\n            delete xhr.modReqHeaders[\"X-Twitter-Client-Version\"];\n        },\n        afterRequest: (xhr) => {\n            try {\n                const response = JSON.parse(xhr.responseText);\n                const entries = response.timeline.instructions.find((i) => i.addEntries).addEntries.entries;\n                const go = response.globalObjects;\n                const tweets = [];\n                for(let entry of entries) {\n                    if(entry.entryId.startsWith(\"notification-\")) {\n                        const sortIndex = entry.sortIndex;\n                        const item = entry.content.item;\n                        const type = item.clientEventInfo.element;\n\n                        switch(type) {\n                            case \"user_mentioned_you\":\n                            case \"user_replied_to_your_tweet\": \n                            case \"user_quoted_your_tweet\":{\n                                const tweetId = item.content.tweet.id;\n                                const tweet = go.tweets[tweetId];\n                                if(!tweet) continue;\n                                tweet.user = go.users[tweet.user_id_str];\n\n                                if(tweet.quoted_status_id_str) {\n                                    tweet.quoted_status = go.tweets[tweet.quoted_status_id_str];\n                                    tweet.quoted_status.user = go.users[tweet.quoted_status.user_id_str];\n                                }\n                                \n                                tweets.push(tweet);\n                                break;\n                            }\n                        }\n                    }\n                }\n                const cursorTop = entries.find(\n                    (e) =>\n                        e.entryId.startsWith(\"sq-cursor-top-\") ||\n                        e.entryId.startsWith(\"cursor-top-\")\n                )?.content?.operation?.cursor?.value;\n                if(cursorTop) {\n                    cursors[`mentions-${xhr.storage.user_id}-top`] = cursorTop;\n                }\n                const cursorBottom = entries.find(\n                    (e) =>\n                        e.entryId.startsWith(\"sq-cursor-bottom-\") ||\n                        e.entryId.startsWith(\"cursor-bottom-\")\n                )?.content?.operation?.cursor?.value;\n                if(cursorBottom) {\n                    cursors[`mentions-${xhr.storage.user_id}-bottom`] = cursorBottom;\n                }\n                \n                return tweets;\n            } catch (e) {\n                console.error(`Error parsing mentions`, e);\n                return [];\n            }\n        }\n    },\n    // User likes timeline\n    {\n        path: \"/1.1/favorites/list.json\",\n        method: \"GET\",\n        beforeRequest: (xhr) => {\n            try {\n                let url = new URL(xhr.modUrl);\n                let params = new URLSearchParams(url.search);\n                let user_id = params.get(\"user_id\") ?? getCurrentUserId();\n                let variables = {\n                    \"userId\": user_id,\n                    \"count\": 50,\n                    \"includePromotedContent\": false,\n                    \"withSuperFollowsUserFields\": true,\n                    \"withDownvotePerspective\": false,\n                    \"withReactionsMetadata\": false,\n                    \"withReactionsPerspective\": false,\n                    \"withSuperFollowsTweetFields\": true,\n                    \"withClientEventToken\": false,\n                    \"withBirdwatchNotes\": false,\n                    \"withVoice\": true,\n                    \"withV2Timeline\": true\n                };\n                let features = {\n                    \"dont_mention_me_view_api_enabled\": true,\n                    \"interactive_text_enabled\": true,\n                    \"responsive_web_uc_gql_enabled\": false,\n                    \"vibe_tweet_context_enabled\": false,\n                    \"responsive_web_edit_tweet_api_enabled\": false,\n                    \"standardized_nudges_misinfo\": false,\n                    \"responsive_web_enhance_cards_enabled\": false\n                };\n\n                let max_id = params.get(\"max_id\");\n                if (max_id) {\n                    let bn = BigInt(params.get(\"max_id\"));\n                    bn += BigInt(1);\n                    if (cursors[`${variables.userId}-${bn}-likes`]) {\n                        variables.cursor = cursors[`${variables.userId}-${bn}-likes`];\n                    }\n                }\n                xhr.storage.user_id = variables.userId;\n\n                xhr.modUrl = `${NEW_API}/vni8vUvtZvJoIsl49VPudg/Likes?${generateParams(\n                    features,\n                    variables\n                )}`;\n            } catch (e) {\n                console.error(e);\n            }\n        },\n        beforeSendHeaders: (xhr) => {\n            xhr.modReqHeaders[\"Content-Type\"] = \"application/json\";\n            xhr.modReqHeaders[\"X-Twitter-Active-User\"] = \"yes\";\n            xhr.modReqHeaders[\"X-Twitter-Client-Language\"] = \"en\";\n            xhr.modReqHeaders[\"Authorization\"] =\n                PUBLIC_TOKENS[0];\n            delete xhr.modReqHeaders[\"X-Twitter-Client-Version\"];\n            // delete xhr.modReqHeaders[\"x-act-as-user-id\"];\n        },\n        afterRequest: (xhr) => {\n            let data;\n            try {\n                data = JSON.parse(xhr.responseText);\n            } catch (e) {\n                console.error(e);\n                return [];\n            }\n            // if (data.errors && data.errors[0]) {\n            //     return [];\n            // }\n            let instructions = data?.data?.user?.result?.timeline_v2?.timeline?.instructions;\n            let entries = instructions?.find((e) => e.type === \"TimelineAddEntries\");\n            if (!entries) {\n                return [];\n            }\n            entries = entries.entries;\n\n            let tweets = entries\n                .filter(e => e.entryId.startsWith('tweet-') && e.content.itemContent.tweet_results.result)\n                .map(e => parseTweet(e.content.itemContent.tweet_results.result))\n                .filter(e => e);\n\n            if (tweets.length === 0) return tweets;\n\n            let cursor = entries.find(\n                (e) =>\n                    e.entryId.startsWith(\"sq-cursor-bottom-\") ||\n                    e.entryId.startsWith(\"cursor-bottom-\")\n            ).content.value;\n            if (cursor) {\n                cursors[`${xhr.storage.user_id}-${tweets[tweets.length - 1].id_str}-likes`] = cursor;\n            }\n\n            // i didn't know they return tweets unsorted???\n            tweets.sort(\n                (a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime()\n            );\n\n            return tweets;\n        },\n    },\n    // Liking / unliking\n    {\n        path: /\\/1\\.1\\/favorites\\/.*\\.json/,\n        method: \"POST\",\n        beforeRequest: (xhr) => {\n            const isFavorite = xhr.modUrl.includes(\"create.json\");\n            xhr.storage.isFavorite = isFavorite;\n\n            xhr.modUrl = isFavorite ? \n                `https://${location.hostname}/i/api/graphql/lI07N6Otwv1PhnEgXILM7A/FavoriteTweet` : \n                `https://${location.hostname}/i/api/graphql/ZYKSe-w7KEslx3JhSIk5LA/UnfavoriteTweet`;\n        },\n        sendHandler: (xhr, data) => {\n            const tweet_id = new URLSearchParams(data).get(\"id\");\n            xhr.send(JSON.stringify({\"variables\":{\"tweet_id\":tweet_id},\"queryId\":xhr.storage.isFavorite ? \"lI07N6Otwv1PhnEgXILM7A\" : \"ZYKSe-w7KEslx3JhSIk5LA\"}));\n        },\n        beforeSendHeaders: (xhr) => {\n            xhr.modReqHeaders[\"Content-Type\"] = \"application/json\";\n            xhr.modReqHeaders[\"X-Twitter-Active-User\"] = \"yes\";\n            xhr.modReqHeaders[\"X-Twitter-Client-Language\"] = \"en\";\n            xhr.modReqHeaders[\"Authorization\"] = PUBLIC_TOKENS[0];\n            delete xhr.modReqHeaders[\"X-Twitter-Client-Version\"];\n        },\n        afterRequest: (xhr) => {\n            return {};\n        },\n    },\n    // Collections\n    {\n        path: /\\/1\\.1\\/collections\\/.*\\.json/,\n        method: \"GET\",\n        openHandler: () => {},\n        sendHandler: emulateResponse,\n        afterRequest: (xhr) => {\n            xhr._status = 404;\n            return \"\";\n        },\n    },\n    {\n        path: /\\/1\\.1\\/collections\\/.*\\.json/,\n        method: \"POST\",\n        openHandler: () => {},\n        sendHandler: emulateResponse,\n        afterRequest: (xhr) => {\n            xhr._status = 404;\n            return \"\";\n        },\n    },\n    // User profile\n    {\n        path: \"/1.1/users/show.json\",\n        method: \"GET\",\n        beforeSendHeaders: (xhr) => {\n            xhr.modReqHeaders[\"X-Twitter-Active-User\"] = \"yes\";\n            xhr.modReqHeaders[\"X-Twitter-Client-Language\"] = \"en\";\n            xhr.modReqHeaders[\"Authorization\"] = PUBLIC_TOKENS[0];\n            delete xhr.modReqHeaders[\"X-Twitter-Client-Version\"];\n        },\n    },\n    // Search\n    {\n        path: \"/1.1/search/universal.json\",\n        method: \"GET\",\n        beforeRequest: (xhr) => {\n            try {\n                let url = new URL(xhr.modUrl);\n                let params = new URLSearchParams(url.search);\n                let variables = {\n                    rawQuery: params.get(\"q\"),\n                    count: 20,\n                    querySource: \"typed_query\",\n                    product: \"Latest\",\n                };\n                let features = {\"responsive_web_graphql_exclude_directive_enabled\":true,\"verified_phone_label_enabled\":false,\"creator_subscriptions_tweet_preview_api_enabled\":true,\"responsive_web_graphql_timeline_navigation_enabled\":true,\"responsive_web_graphql_skip_user_profile_image_extensions_enabled\":false,\"communities_web_enable_tweet_community_results_fetch\":true,\"c9s_tweet_anatomy_moderator_badge_enabled\":true,\"tweetypie_unmention_optimization_enabled\":true,\"responsive_web_edit_tweet_api_enabled\":true,\"graphql_is_translatable_rweb_tweet_is_translatable_enabled\":true,\"view_counts_everywhere_api_enabled\":true,\"longform_notetweets_consumption_enabled\":true,\"responsive_web_twitter_article_tweet_consumption_enabled\":true,\"tweet_awards_web_tipping_enabled\":false,\"freedom_of_speech_not_reach_fetch_enabled\":true,\"standardized_nudges_misinfo\":true,\"tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled\":true,\"rweb_video_timestamps_enabled\":true,\"longform_notetweets_rich_text_read_enabled\":true,\"longform_notetweets_inline_media_enabled\":true,\"responsive_web_enhance_cards_enabled\":false};\n\n                xhr.storage.query = variables.rawQuery;\n                xhr.storage.cursor = params.get(\"since_id\");\n                xhr.modUrl = `${NEW_API}/l0dLMlz_fHji3FT8AfrvxA/SearchTimeline?${generateParams(\n                    features,\n                    variables\n                )}`;\n            } catch (e) {\n                console.error(e);\n            }\n        },\n        openHandler: (xhr, method, url, async, username, password) => {\n            if(!timings.search[xhr.storage.query]) {\n                timings.search[xhr.storage.query] = 0;\n            }\n            if(Date.now() - timings.search[xhr.storage.query] < 60000*1.5 && xhr.storage.cursor) {\n                xhr.storage.cancelled = true;\n            } else {\n                xhr.open(method, url, async, username, password);\n                timings.search[xhr.storage.query] = Date.now();\n            }\n        },\n        sendHandler: (xhr, data) => {\n            if(xhr.storage.cancelled) {\n                emulateResponse(xhr);\n            } else {\n                xhr.send(data);\n            }\n        },\n        beforeSendHeaders: (xhr) => {\n            xhr.modReqHeaders[\"Content-Type\"] = \"application/json\";\n            xhr.modReqHeaders[\"X-Twitter-Active-User\"] = \"yes\";\n            xhr.modReqHeaders[\"X-Twitter-Client-Language\"] = \"en\";\n            xhr.modReqHeaders[\"Authorization\"] =\n                PUBLIC_TOKENS[0];\n            delete xhr.modReqHeaders[\"X-Twitter-Client-Version\"];\n        },\n        afterRequest: (xhr) => {\n            if(xhr.storage.cancelled) {\n                return [];\n            }\n            let data;\n            try {\n                data = JSON.parse(xhr.responseText);\n            } catch (e) {\n                console.error(e);\n                return [];\n            }\n            // if (data.errors && data.errors[0]) {\n            //     return [];\n            // }\n            let instructions = data?.data?.search_by_raw_query?.search_timeline?.timeline?.instructions;\n            let entries = instructions?.find((i) => i.entries);\n            if (!entries) {\n                return [];\n            }\n            entries = entries.entries;\n            let res = [];\n            for (let entry of entries) {\n                if (entry.entryId.startsWith(\"sq-I-t-\") || entry.entryId.startsWith(\"tweet-\")) {\n                    let result = entry.content.itemContent.tweet_results.result;\n\n                    if (entry.content.itemContent.promotedMetadata) {\n                        continue;\n                    }\n                    let tweet = parseTweet(result);\n                    if (!tweet) {\n                        continue;\n                    }\n                    res.push(tweet);\n                }\n            }\n            let cursor = entries.find(\n                (e) =>\n                    e.entryId.startsWith(\"sq-cursor-bottom-\") ||\n                    e.entryId.startsWith(\"cursor-bottom-\")\n            );\n            if (cursor) {\n                cursor = cursor.content.value;\n            } else {\n                cursor = instructions.find(\n                    (e) =>\n                        e.entry_id_to_replace &&\n                        (e.entry_id_to_replace.startsWith(\"sq-cursor-bottom-\") ||\n                            e.entry_id_to_replace.startsWith(\"cursor-bottom-\"))\n                );\n                if (cursor) {\n                    cursor = cursor.entry.content.value;\n                } else {\n                    cursor = null;\n                }\n            }\n\n            return {\n                metadata: {\n                    cursor,\n                    refresh_interval_in_sec: 30,\n                },\n                modules: res.map((t) => ({ status: { data: t } })),\n            };\n        },\n    },\n    // User search\n    {\n        path: \"/1.1/users/search.json\",\n        method: \"GET\",\n        beforeRequest: (xhr) => {\n            try {\n                let url = new URL(xhr.modUrl);\n                let params = new URLSearchParams(url.search);\n                let variables = {\n                    rawQuery: params.get(\"q\"),\n                    count: 20,\n                    querySource: \"typed_query\",\n                    product: \"People\",\n                };\n                let features = {\n                    rweb_lists_timeline_redesign_enabled: false,\n                    responsive_web_graphql_exclude_directive_enabled: true,\n                    verified_phone_label_enabled: false,\n                    creator_subscriptions_tweet_preview_api_enabled: true,\n                    responsive_web_graphql_timeline_navigation_enabled: true,\n                    responsive_web_graphql_skip_user_profile_image_extensions_enabled: false,\n                    tweetypie_unmention_optimization_enabled: true,\n                    responsive_web_edit_tweet_api_enabled: true,\n                    graphql_is_translatable_rweb_tweet_is_translatable_enabled: true,\n                    view_counts_everywhere_api_enabled: true,\n                    longform_notetweets_consumption_enabled: true,\n                    responsive_web_twitter_article_tweet_consumption_enabled: false,\n                    tweet_awards_web_tipping_enabled: false,\n                    freedom_of_speech_not_reach_fetch_enabled: true,\n                    standardized_nudges_misinfo: true,\n                    tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled: true,\n                    longform_notetweets_rich_text_read_enabled: true,\n                    longform_notetweets_inline_media_enabled: true,\n                    responsive_web_media_download_video_enabled: false,\n                    responsive_web_enhance_cards_enabled: false,\n                };\n\n                xhr.modUrl = `${NEW_API}/nK1dw4oV3k4w5TdtcAdSww/SearchTimeline?${generateParams(\n                    features,\n                    variables\n                )}`;\n            } catch (e) {\n                console.error(e);\n            }\n        },\n        beforeSendHeaders: (xhr) => {\n            xhr.modReqHeaders[\"Content-Type\"] = \"application/json\";\n            xhr.modReqHeaders[\"X-Twitter-Active-User\"] = \"yes\";\n            xhr.modReqHeaders[\"X-Twitter-Client-Language\"] = \"en\";\n            xhr.modReqHeaders[\"Authorization\"] =\n                PUBLIC_TOKENS[0];\n            delete xhr.modReqHeaders[\"X-Twitter-Client-Version\"];\n        },\n        afterRequest: (xhr) => {\n            let data;\n            try {\n                data = JSON.parse(xhr.responseText);\n            } catch (e) {\n                console.error(e);\n                return [];\n            }\n            if (data.errors && data.errors[0]) {\n                return [];\n            }\n            let instructions = data.data.search_by_raw_query.search_timeline.timeline.instructions;\n            let entries = instructions.find((i) => i.entries);\n            if (!entries) {\n                return [];\n            }\n            entries = entries.entries;\n            let res = [];\n            for (let entry of entries) {\n                if (entry.entryId.startsWith(\"sq-I-u-\") || entry.entryId.startsWith(\"user-\")) {\n                    let result = entry.content.itemContent.user_results.result;\n                    if (!result || !result.legacy) {\n                        console.log(\"Bug: no user\", entry);\n                        continue;\n                    }\n                    let user = result.legacy;\n                    user.id_str = result.rest_id;\n                    res.push(user);\n                }\n            }\n            let cursor = entries.find(\n                (e) =>\n                    e.entryId.startsWith(\"sq-cursor-bottom-\") ||\n                    e.entryId.startsWith(\"cursor-bottom-\")\n            );\n            if (cursor) {\n                cursor = cursor.content.value;\n            } else {\n                cursor = instructions.find(\n                    (e) =>\n                        e.entry_id_to_replace &&\n                        (e.entry_id_to_replace.startsWith(\"sq-cursor-bottom-\") ||\n                            e.entry_id_to_replace.startsWith(\"cursor-bottom-\"))\n                );\n                if (cursor) {\n                    cursor = cursor.entry.content.value;\n                } else {\n                    cursor = null;\n                }\n            }\n\n            return res;\n        },\n    },\n    // Tweet creation\n    {\n        path: \"/1.1/statuses/update.json\",\n        method: \"POST\",\n        beforeRequest: (xhr) => {\n            xhr.modUrl = `https://${location.hostname}/i/api/graphql/oB-5XsHNAbjvARJEc8CZFw/CreateTweet`;\n        },\n        beforeSendHeaders: (xhr) => {\n            xhr.modReqHeaders[\"Content-Type\"] = \"application/json\";\n            xhr.modReqHeaders[\"X-Twitter-Active-User\"] = \"yes\";\n            xhr.modReqHeaders[\"X-Twitter-Client-Language\"] = \"en\";\n            xhr.modReqHeaders[\"Authorization\"] = PUBLIC_TOKENS[0];\n            delete xhr.modReqHeaders[\"X-Twitter-Client-Version\"];\n        },\n        beforeSendBody: (xhr, body) => {\n            let params = Object.fromEntries(new URLSearchParams(body));\n            let variables = {\n                tweet_text: params.status,\n                media: {\n                    media_entities: [],\n                    possibly_sensitive: false,\n                },\n                semantic_annotation_ids: [],\n                dark_request: false,\n            };\n            if (params.in_reply_to_status_id) {\n                variables.reply = {\n                    in_reply_to_tweet_id: params.in_reply_to_status_id,\n                    exclude_reply_user_ids: [],\n                };\n                if (params.exclude_reply_user_ids) {\n                    variables.reply.exclude_reply_user_ids =\n                        params.exclude_reply_user_ids.split(\",\");\n                }\n            }\n            if (params.media_ids) {\n                variables.media.media_entities = params.media_ids\n                    .split(\",\")\n                    .map((id) => ({ media_id: id, tagged_users: [] }));\n            }\n            if (params.attachment_url) {\n                variables.attachment_url = params.attachment_url;\n            }\n\n            return JSON.stringify({\n                variables,\n                features: {\"communities_web_enable_tweet_community_results_fetch\":true,\"c9s_tweet_anatomy_moderator_badge_enabled\":true,\"tweetypie_unmention_optimization_enabled\":true,\"responsive_web_edit_tweet_api_enabled\":true,\"graphql_is_translatable_rweb_tweet_is_translatable_enabled\":true,\"view_counts_everywhere_api_enabled\":true,\"longform_notetweets_consumption_enabled\":true,\"responsive_web_twitter_article_tweet_consumption_enabled\":true,\"tweet_awards_web_tipping_enabled\":false,\"creator_subscriptions_quote_tweet_preview_enabled\":false,\"longform_notetweets_rich_text_read_enabled\":true,\"longform_notetweets_inline_media_enabled\":true,\"articles_preview_enabled\":true,\"rweb_video_timestamps_enabled\":true,\"rweb_tipjar_consumption_enabled\":true,\"responsive_web_graphql_exclude_directive_enabled\":true,\"verified_phone_label_enabled\":false,\"freedom_of_speech_not_reach_fetch_enabled\":true,\"standardized_nudges_misinfo\":true,\"tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled\":true,\"responsive_web_graphql_skip_user_profile_image_extensions_enabled\":false,\"responsive_web_graphql_timeline_navigation_enabled\":true,\"responsive_web_enhance_cards_enabled\":false},\n                queryId: \"oB-5XsHNAbjvARJEc8CZFw\",\n            });\n        },\n        afterRequest: (xhr) => {\n            let data;\n            try {\n                data = JSON.parse(xhr.responseText);\n            } catch (e) {\n                console.error(e);\n                return {};\n            }\n            if (data.errors && data.errors[0]) {\n                return {};\n            }\n            let tweet = parseTweet(data.data.create_tweet.tweet_results.result);\n            return tweet;\n        },\n    },\n    // Retweeting\n    {\n        path: /\\/1.1\\/statuses\\/retweet\\/(\\d+).json/,\n        method: \"POST\",\n        beforeRequest: (xhr) => {\n            let originalUrl = new URL(xhr.originalUrl);\n            xhr.storage.tweet_id = originalUrl.pathname.match(\n                /\\/1.1\\/statuses\\/retweet\\/(\\d+).json/\n            )[1];\n            xhr.storage.retweeter = getCurrentUserId();\n            xhr.modUrl = `https://${location.hostname}/i/api/graphql/ojPdsZsimiJrUGLR1sjUtA/CreateRetweet`;\n        },\n        beforeSendHeaders: (xhr) => {\n            xhr.modReqHeaders[\"Content-Type\"] = \"application/json\";\n            xhr.modReqHeaders[\"X-Twitter-Active-User\"] = \"yes\";\n            xhr.modReqHeaders[\"X-Twitter-Client-Language\"] = \"en\";\n            xhr.modReqHeaders[\"Authorization\"] = PUBLIC_TOKENS[0];\n            delete xhr.modReqHeaders[\"X-Twitter-Client-Version\"];\n            if (xhr.modReqHeaders[\"x-act-as-user-id\"]) {\n                xhr.storage.retweeter = xhr.modReqHeaders[\"x-act-as-user-id\"];\n            }\n        },\n        beforeSendBody: (xhr, body) => {\n            return JSON.stringify({\n                variables: {\n                    tweet_id: xhr.storage.tweet_id,\n                    dark_request: false,\n                },\n                queryId: \"ojPdsZsimiJrUGLR1sjUtA\",\n            });\n        },\n        afterRequest: (xhr) => {\n            let data;\n            try {\n                data = JSON.parse(xhr.responseText);\n            } catch (e) {\n                console.error(e);\n                return {};\n            }\n            if (data.errors && data.errors[0]) {\n                return {};\n            }\n            let res = data.data.create_retweet.retweet_results.result;\n            let tweet = res.legacy;\n            tweet.id_str = res.rest_id;\n            if (!tweet.user) {\n                tweet.user = {\n                    id_str: xhr.storage.retweeter,\n                };\n            }\n            return tweet;\n        },\n    },\n    // Unretweeting\n    {\n        path: /\\/1.1\\/statuses\\/unretweet\\/(\\d+).json/,\n        method: \"POST\",\n        beforeRequest: (xhr) => {\n            let originalUrl = new URL(xhr.originalUrl);\n            xhr.storage.tweet_id = originalUrl.pathname.match(\n                /\\/1.1\\/statuses\\/unretweet\\/(\\d+).json/\n            )[1];\n            xhr.storage.retweeter = getCurrentUserId();\n            xhr.modUrl = `https://${location.hostname}/i/api/graphql/iQtK4dl5hBmXewYZuEOKVw/DeleteRetweet`;\n        },\n        beforeSendHeaders: (xhr) => {\n            xhr.modReqHeaders[\"Content-Type\"] = \"application/json\";\n            xhr.modReqHeaders[\"X-Twitter-Active-User\"] = \"yes\";\n            xhr.modReqHeaders[\"X-Twitter-Client-Language\"] = \"en\";\n            xhr.modReqHeaders[\"Authorization\"] =\n                PUBLIC_TOKENS[0];\n            delete xhr.modReqHeaders[\"X-Twitter-Client-Version\"];\n            if (xhr.modReqHeaders[\"x-act-as-user-id\"]) {\n                xhr.storage.retweeter = xhr.modReqHeaders[\"x-act-as-user-id\"];\n            }\n        },\n        beforeSendBody: (xhr, body) => {\n            return JSON.stringify({\n                variables: { source_tweet_id: xhr.storage.tweet_id, dark_request: false },\n                queryId: \"iQtK4dl5hBmXewYZuEOKVw\",\n            });\n        },\n        afterRequest: (xhr) => {\n            let data;\n            try {\n                data = JSON.parse(xhr.responseText);\n            } catch (e) {\n                console.error(e);\n                return {};\n            }\n            if (data.errors && data.errors[0]) {\n                return {};\n            }\n            let res = data.data.unretweet.source_tweet_results.result;\n            let tweet = res.legacy;\n            tweet.id_str = res.rest_id;\n            if (!tweet.user) {\n                tweet.user = {\n                    id_str: xhr.storage.retweeter,\n                };\n            }\n            return tweet;\n        },\n    },\n    // Getting tweet details\n    {\n        path: /\\/1.1\\/statuses\\/show\\/(\\d+).json/,\n        method: \"GET\",\n        beforeRequest: (xhr) => {\n            let originalUrl = new URL(xhr.originalUrl);\n            xhr.storage.tweet_id = originalUrl.pathname.match(\n                /\\/1.1\\/statuses\\/show\\/(\\d+).json/\n            )[1];\n            xhr.modUrl = `https://${location.hostname}/i/api/graphql/KwGBbJZc6DBx8EKmyQSP7g/TweetDetail?variables=${encodeURIComponent(\n                JSON.stringify({\n                    focalTweetId: xhr.storage.tweet_id,\n                    with_rux_injections: false,\n                    includePromotedContent: false,\n                    withCommunity: true,\n                    withQuickPromoteEligibilityTweetFields: true,\n                    withBirdwatchNotes: true,\n                    withVoice: true,\n                    withV2Timeline: true,\n                })\n            )}&features=${encodeURIComponent(\n                JSON.stringify({\n                    rweb_lists_timeline_redesign_enabled: false,\n                    blue_business_profile_image_shape_enabled: true,\n                    responsive_web_graphql_exclude_directive_enabled: true,\n                    verified_phone_label_enabled: false,\n                    creator_subscriptions_tweet_preview_api_enabled: false,\n                    responsive_web_graphql_timeline_navigation_enabled: true,\n                    responsive_web_graphql_skip_user_profile_image_extensions_enabled: false,\n                    tweetypie_unmention_optimization_enabled: true,\n                    vibe_api_enabled: true,\n                    responsive_web_edit_tweet_api_enabled: true,\n                    graphql_is_translatable_rweb_tweet_is_translatable_enabled: true,\n                    view_counts_everywhere_api_enabled: true,\n                    longform_notetweets_consumption_enabled: true,\n                    tweet_awards_web_tipping_enabled: false,\n                    freedom_of_speech_not_reach_fetch_enabled: true,\n                    standardized_nudges_misinfo: true,\n                    tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled: false,\n                    interactive_text_enabled: true,\n                    responsive_web_text_conversations_enabled: false,\n                    longform_notetweets_rich_text_read_enabled: true,\n                    longform_notetweets_inline_media_enabled: false,\n                    responsive_web_enhance_cards_enabled: false,\n                })\n            )}`;\n        },\n        beforeSendHeaders: (xhr) => {\n            xhr.modReqHeaders[\"Content-Type\"] = \"application/json\";\n            xhr.modReqHeaders[\"X-Twitter-Active-User\"] = \"yes\";\n            xhr.modReqHeaders[\"X-Twitter-Client-Language\"] = \"en\";\n            xhr.modReqHeaders[\"Authorization\"] =\n                PUBLIC_TOKENS[0];\n            delete xhr.modReqHeaders[\"X-Twitter-Client-Version\"];\n        },\n        afterRequest: (xhr) => {\n            let data;\n            try {\n                data = JSON.parse(xhr.responseText);\n            } catch (e) {\n                console.error(e);\n                return {};\n            }\n            if (data.errors && data.errors[0]) {\n                return {};\n            }\n            let ic = data.data.threaded_conversation_with_injections_v2.instructions\n                .find((i) => i.type === \"TimelineAddEntries\")\n                .entries.find((e) => e.entryId === `tweet-${xhr.storage.tweet_id}`)\n                .content.itemContent;\n            let res = ic.tweet_results.result;\n            let tweet = parseTweet(res);\n            return tweet;\n        },\n    },\n    {\n        path: \"/1.1/statuses/show.json\",\n        method: \"GET\",\n        beforeRequest: (xhr) => {\n            let originalUrl = new URL(xhr.originalUrl);\n            xhr.storage.tweet_id = originalUrl.searchParams.get(\"id\");\n            xhr.modUrl = `https://${location.hostname}/i/api/graphql/KwGBbJZc6DBx8EKmyQSP7g/TweetDetail?variables=${encodeURIComponent(\n                JSON.stringify({\n                    focalTweetId: xhr.storage.tweet_id,\n                    with_rux_injections: false,\n                    includePromotedContent: false,\n                    withCommunity: true,\n                    withQuickPromoteEligibilityTweetFields: true,\n                    withBirdwatchNotes: true,\n                    withVoice: true,\n                    withV2Timeline: true,\n                })\n            )}&features=${encodeURIComponent(\n                JSON.stringify({\n                    rweb_lists_timeline_redesign_enabled: false,\n                    blue_business_profile_image_shape_enabled: true,\n                    responsive_web_graphql_exclude_directive_enabled: true,\n                    verified_phone_label_enabled: false,\n                    creator_subscriptions_tweet_preview_api_enabled: false,\n                    responsive_web_graphql_timeline_navigation_enabled: true,\n                    responsive_web_graphql_skip_user_profile_image_extensions_enabled: false,\n                    tweetypie_unmention_optimization_enabled: true,\n                    vibe_api_enabled: true,\n                    responsive_web_edit_tweet_api_enabled: true,\n                    graphql_is_translatable_rweb_tweet_is_translatable_enabled: true,\n                    view_counts_everywhere_api_enabled: true,\n                    longform_notetweets_consumption_enabled: true,\n                    tweet_awards_web_tipping_enabled: false,\n                    freedom_of_speech_not_reach_fetch_enabled: true,\n                    standardized_nudges_misinfo: true,\n                    tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled: false,\n                    interactive_text_enabled: true,\n                    responsive_web_text_conversations_enabled: false,\n                    longform_notetweets_rich_text_read_enabled: true,\n                    longform_notetweets_inline_media_enabled: false,\n                    responsive_web_enhance_cards_enabled: false,\n                })\n            )}`;\n        },\n        beforeSendHeaders: (xhr) => {\n            xhr.modReqHeaders[\"Content-Type\"] = \"application/json\";\n            xhr.modReqHeaders[\"X-Twitter-Active-User\"] = \"yes\";\n            xhr.modReqHeaders[\"X-Twitter-Client-Language\"] = \"en\";\n            xhr.modReqHeaders[\"Authorization\"] =\n                PUBLIC_TOKENS[0];\n            delete xhr.modReqHeaders[\"X-Twitter-Client-Version\"];\n        },\n        afterRequest: (xhr) => {\n            let data;\n            try {\n                data = JSON.parse(xhr.responseText);\n            } catch (e) {\n                console.error(e);\n                return {};\n            }\n            if (data.errors && data.errors[0]) {\n                return {};\n            }\n            let ic = data.data.threaded_conversation_with_injections_v2.instructions\n                .find((i) => i.type === \"TimelineAddEntries\")\n                .entries.find((e) => e.entryId === `tweet-${xhr.storage.tweet_id}`)\n                .content.itemContent;\n            let res = ic.tweet_results.result;\n            let tweet = parseTweet(res);\n            return tweet;\n        },\n    },\n    // Tweet deletion\n    {\n        path: /\\/1.1\\/statuses\\/destroy\\/(\\d+).json/,\n        method: \"POST\",\n        beforeRequest: (xhr) => {\n            let originalUrl = new URL(xhr.originalUrl);\n            xhr.storage.tweet_id = originalUrl.pathname.match(\n                /\\/1.1\\/statuses\\/destroy\\/(\\d+).json/\n            )[1];\n            xhr.modUrl = `https://${location.hostname}/i/api/graphql/VaenaVgh5q5ih7kvyVjgtg/DeleteTweet`;\n        },\n        beforeSendHeaders: (xhr) => {\n            xhr.modReqHeaders[\"Content-Type\"] = \"application/json\";\n            xhr.modReqHeaders[\"X-Twitter-Active-User\"] = \"yes\";\n            xhr.modReqHeaders[\"X-Twitter-Client-Language\"] = \"en\";\n            xhr.modReqHeaders[\"Authorization\"] =\n                PUBLIC_TOKENS[0];\n            delete xhr.modReqHeaders[\"X-Twitter-Client-Version\"];\n        },\n        beforeSendBody: (xhr, body) => {\n            return JSON.stringify({\n                variables: { tweet_id: xhr.storage.tweet_id, dark_request: false },\n                queryId: \"VaenaVgh5q5ih7kvyVjgtg\",\n            });\n        },\n    },\n    // Tweet replies\n    {\n        path: /\\/2\\/timeline\\/conversation\\/(\\d+).json/,\n        method: \"GET\",\n        beforeRequest: (xhr) => {\n            let originalUrl = new URL(xhr.originalUrl);\n            let params = new URLSearchParams(originalUrl.search);\n\n            params.delete(\"ext\");\n            params.delete(\"include_ext_has_nft_avatar\");\n            params.delete(\"include_ext_is_blue_verified\");\n            params.delete(\"include_ext_verified_type\");\n            params.delete(\"include_ext_sensitive_media_warning\");\n            params.delete(\"include_ext_media_color\");\n\n            originalUrl.search = params.toString();\n\n            xhr.modUrl = originalUrl.toString();\n        },\n        beforeSendHeaders: (xhr) => {\n            xhr.modReqHeaders[\"X-Twitter-Active-User\"] = \"yes\";\n            xhr.modReqHeaders[\"X-Twitter-Client-Language\"] = \"en\";\n            xhr.modReqHeaders[\"Authorization\"] =\n                PUBLIC_TOKENS[0];\n            delete xhr.modReqHeaders[\"X-Twitter-Client-Version\"];\n        },\n        afterRequest: (xhr) => {\n            let data;\n            try {\n                data = JSON.parse(xhr.responseText);\n            } catch (e) {\n                console.error(e);\n                return data;\n            }\n            if (data.errors && data.errors[0]) {\n                return data;\n            }\n            for (let id in data.globalObjects.tweets) {\n                let tweet = data.globalObjects.tweets[id];\n\n                if (!tweet.contributors) tweet.contributors = null;\n                if (tweet.conversation_id_str)\n                    tweet.conversation_id = parseInt(tweet.conversation_id_str);\n                if (!tweet.coordinates) tweet.coordinates = null;\n                if (!tweet.conversation_muted) tweet.conversation_muted = false;\n                if (!tweet.favorited) tweet.favorited = false;\n                if (!tweet.geo) tweet.geo = null;\n                if (!tweet.id) tweet.id = parseInt(id);\n                if (!tweet.in_reply_to_screen_name) tweet.in_reply_to_screen_name = null;\n                if (!tweet.in_reply_to_status_id) tweet.in_reply_to_status_id = null;\n                if (!tweet.in_reply_to_status_id_str) tweet.in_reply_to_status_id_str = null;\n                if (!tweet.in_reply_to_user_id) tweet.in_reply_to_user_id = null;\n                if (!tweet.in_reply_to_user_id_str) tweet.in_reply_to_user_id_str = null;\n                if (!tweet.is_quote_status) tweet.is_quote_status = false;\n                if (!tweet.place) tweet.place = null;\n                if (!tweet.supplemental_language) tweet.supplemental_language = null;\n                if (!tweet.retweeted) tweet.retweeted = false;\n                if (!tweet.truncated) tweet.truncated = false;\n                if (!tweet.user_id) tweet.user_id = parseInt(tweet.user_id_str);\n            }\n\n            for (let id in data.globalObjects.users) {\n                let user = data.globalObjects.users[id];\n\n                if (!user.default_profile) user.default_profile = false;\n                if (!user.default_profile_image) user.default_profile_image = false;\n                if (!user.entities.description) user.entities.description = { urls: [] };\n                if (!user.entities.description.urls) user.entities.description.urls = [];\n                if (!user.entities.url) user.entities.url = { urls: [] };\n                if (!user.entities.url.urls) user.entities.url.urls = [];\n                if (!user.follow_request_sent) user.follow_request_sent = false;\n                if (!user.following) user.following = false;\n                if (!user.has_extended_profile) user.has_extended_profile = false;\n                if (!user.is_translation_enabled) user.is_translation_enabled = false;\n                if (!user.is_translator) user.is_translator = false;\n                if (!user.followed_by) user.followed_by = false;\n                if (!user.id) user.id = parseInt(id);\n                if (!user.lang) user.lang = null;\n                if (!user.notifications) user.notifications = false;\n                if (!user.profile_background_color) user.profile_background_color = \"C0DEED\";\n                if (!user.profile_background_image_url)\n                    user.profile_background_image_url =\n                        \"http://abs.twimg.com/images/themes/theme1/bg.png\";\n                if (!user.profile_background_image_url_https)\n                    user.profile_background_image_url_https =\n                        \"https://abs.twimg.com/images/themes/theme1/bg.png\";\n                if (!user.profile_background_tile) user.profile_background_tile = false;\n                if (!user.profile_link_color) user.profile_link_color = \"1DA1F2\";\n                if (!user.profile_image_url && user.profile_image_url_https)\n                    user.profile_image_url = user.profile_image_url_https.replace(\n                        \"https://\",\n                        \"http://\"\n                    );\n                if (!user.profile_sidebar_border_color)\n                    user.profile_sidebar_border_color = \"000000\";\n                if (!user.profile_sidebar_fill_color) user.profile_sidebar_fill_color = \"DDEEF6\";\n                if (!user.profile_text_color) user.profile_text_color = \"333333\";\n                if (!user.profile_use_background_image) user.profile_use_background_image = true;\n                if (!user.protected) user.protected = false;\n                if (!user.require_some_consent) user.require_some_consent = false;\n                if (!user.time_zone) user.time_zone = null;\n                if (!user.utc_offset) user.utc_offset = null;\n                if (!user.verified) user.verified = false;\n            }\n\n            let entries = data.timeline.instructions.find((i) => i.addEntries);\n            if (entries) {\n                entries.addEntries.entries = entries.addEntries.entries.filter(\n                    (e) => !e.entryId.startsWith(\"tweetComposer-\")\n                );\n                for (let entry of entries.addEntries.entries) {\n                    if (entry.entryId.startsWith(\"conversationThread-\")) {\n                        let newContent = {\n                            item: {\n                                content: {\n                                    conversationThread: {\n                                        conversationComponents: [],\n                                    },\n                                },\n                            },\n                        };\n                        if (entry.content.timelineModule.items)\n                            for (let item of entry.content.timelineModule.items) {\n                                if (item.item && item.item.content && item.item.content.tweet) {\n                                    newContent.item.content.conversationThread.conversationComponents.push(\n                                        {\n                                            conversationTweetComponent: {\n                                                tweet: item.item.content.tweet,\n                                            },\n                                        }\n                                    );\n                                }\n                            }\n                        entry.content = newContent;\n                    }\n                }\n            }\n\n            return data;\n        },\n    },\n    // getting user\n    {\n        path: \"/1.1/account/verify_credentials.json\",\n        method: \"GET\",\n        beforeRequest: (xhr) => {\n            // xhr.modUrl = `https://x.com/home/`;\n        },\n        beforeSendHeaders: (xhr) => {\n            // delete xhr.modReqHeaders[\"Content-Type\"];\n            // delete xhr.modReqHeaders[\"X-Twitter-Active-User\"];\n            // delete xhr.modReqHeaders[\"X-Twitter-Client-Language\"];\n            // delete xhr.modReqHeaders[\"X-Twitter-Auth-Type\"];\n            // delete xhr.modReqHeaders[\"Authorization\"];\n            // delete xhr.modReqHeaders[\"X-Csrf-Token\"];\n            xhr.storage.user_id = xhr.modReqHeaders[\"x-act-as-user-id\"];\n            xhr.modReqHeaders[\"Content-Type\"] = \"application/json\";\n            xhr.modReqHeaders[\"X-Twitter-Active-User\"] = \"yes\";\n            xhr.modReqHeaders[\"X-Twitter-Client-Language\"] = \"en\";\n            xhr.modReqHeaders[\"Authorization\"] =\n                PUBLIC_TOKENS[0];\n            delete xhr.modReqHeaders[\"X-Twitter-Client-Version\"];\n\n        },\n        afterRequest: (xhr) => {\n            const data = JSON.parse(xhr.responseText);\n            try {\n                if(!xhr.storage.user_id && !data.errors) {\n                    localStorage.OTDverifiedUser = JSON.stringify(data);\n                    verifiedUser = data;\n                } \n            } catch (e) {\n                console.error('error parsing verified user', e);\n            }\n            return data;\n        },\n        // afterRequest: (xhr) => {\n        //     try {\n        //         const state = extractAssignedJSON(xhr.responseText);\n        //         const user_id = state.session.user_id;\n        //         const user = state.entities.users.entities[user_id];\n        //         if(!user) {\n        //             console.error(`User not found: ${JSON.stringify(state)}`);\n        //             if(localStorage.OTDverifiedUser) {\n        //                 try {\n        //                     verifiedUser = JSON.parse(localStorage.OTDverifiedUser);\n        //                     console.warn(\"Using verified user from localStorage\");\n        //                     return verifiedUser;\n        //                 } catch (e) {}\n        //             }\n        //             throw new Error('User not found');\n        //         }\n        //         verifiedUser = user;\n        //         localStorage.OTDverifiedUser = JSON.stringify(user);\n        //         return user;\n        //     } catch (e) {\n        //         console.error(`Failed to get user data`, e);\n        //         return null;\n        //     }\n        // }\n    },\n    // DM messages\n    {\n        path: /\\/1.1\\/dm\\/conversation\\/(\\d+)-(\\d+).json/,\n        method: \"GET\",\n        afterRequest: (xhr) => {\n            return xhr.responseText.replaceAll(\"\\\\/\\\\/ton.twitter.com\\\\/1.1\", \"\\\\/\\\\/ton.x.com\\\\/i\");\n        }\n    },\n    // Inbox\n    {\n        path: \"/1.1/dm/user_updates.json\",\n        method: \"GET\",\n        afterRequest: (xhr) => {\n            return xhr.responseText.replaceAll(\"\\\\/\\\\/ton.twitter.com\\\\/1.1\", \"\\\\/\\\\/ton.x.com\\\\/i\");\n        }\n    },\n    // Translating tweets\n    {\n        path: \"/1.1/translations/show.json\",\n        method: \"GET\",\n        beforeRequest: (xhr) => {\n            let url = new URL(xhr.modUrl);\n            let params = new URLSearchParams(url.search);\n            let tweet_id = params.get(\"id\");\n            let dest = params.get(\"dest\");\n            xhr.modUrl = `https://${location.hostname}/i/api/1.1/strato/column/None/tweetId=${tweet_id},destinationLanguage=None,translationSource=Some(Google),feature=None,timeout=None,onlyCached=None/translation/service/translateTweet`;\n        },\n        beforeSendHeaders: (xhr) => {\n            xhr.modReqHeaders[\"Content-Type\"] = \"application/json\";\n            xhr.modReqHeaders[\"X-Twitter-Active-User\"] = \"yes\";\n            xhr.modReqHeaders[\"X-Twitter-Client-Language\"] = navigator.language.split(\"-\")[0];\n            xhr.modReqHeaders[\"Authorization\"] =\n                PUBLIC_TOKENS[0];\n            delete xhr.modReqHeaders[\"X-Twitter-Client-Version\"];\n        },\n        afterRequest: (xhr) => {\n            const response = JSON.parse(xhr.responseText);\n\n            return JSON.stringify({\n                text: response.translation,\n                entities: response.entities,\n                translated_lang: response.sourceLanguage,\n            });\n        }\n    },\n\n    // TweetDeck state\n    {\n        path: \"/1.1/tweetdeck/clients/blackbird/all\",\n        method: \"GET\",\n        openHandler: () => {},\n        sendHandler: emulateResponse,\n        afterRequest: (xhr) => {\n            const state = {\n                client: {\n                    columns: localStorage.OTDcolumnIds ? JSON.parse(localStorage.OTDcolumnIds) : [],\n                    mtime: new Date().toISOString(),\n                    name: \"blackbird\",\n                    settings: settings ?? {\n                        account_whitelist: [`twitter:${verifiedUser.id_str}`],\n                        default_account: `twitter:${verifiedUser.id_str}`,\n                        recent_searches: [],\n                        display_sensitive_media: false,\n                        name_cache: {\n                            customTimelines: {},\n                            lists: {},\n                            users: {}\n                        },\n                        navbar_width: \"full-size\",\n                        previous_splash_version: \"4.0.220811153004\",\n                        show_search_filter_callout: false,\n                        show_trends_filter_callout: false,\n                        theme: \"light\",\n                        use_narrow_columns: null,\n                        version: 2\n                    },\n                },\n                columns: columns ?? {},\n                decider: {},\n                feeds: feeds ?? {},\n                messages: [],\n                new: true\n            };\n            if(!settings) {\n                settings = state.client.settings;\n                localStorage.OTDsettings = JSON.stringify(settings);\n            }\n            cleanUp();\n            console.log('account state', state);\n\n            return state;\n        },\n    },\n    // emulate sending state data\n    {\n        path: \"/1.1/tweetdeck/clients/blackbird\",\n        method: \"POST\",\n        responseHeaderOverride: {\n            \"x-td-mtime\": () => {\n                return new Date().toISOString();\n            },\n        },\n        openHandler: () => {},\n        sendHandler: emulateResponse,\n        beforeSendBody: (xhr, body) => {\n            let json = JSON.parse(body);\n            console.log('state push', json);\n            if(json.columns) {\n                localStorage.OTDcolumnIds = JSON.stringify(json.columns);\n            }\n            if(json.settings && settings) {\n                for(let key in json.settings) {\n                    settings[key] = json.settings[key];\n                }\n                localStorage.OTDsettings = JSON.stringify(settings);\n            }\n            cleanUp();\n            return body;\n        },\n        afterRequest: (xhr) => {\n            return \"\";\n        }\n    },\n    // emulate sending feeds\n    {\n        path: \"/1.1/tweetdeck/feeds\",\n        method: \"POST\",\n        responseHeaderOverride: {\n            \"X-Td-Mtime\": () => {\n                return new Date().toISOString();\n            },\n        },\n        openHandler: () => {},\n        sendHandler: emulateResponse,\n        beforeSendBody: (xhr, body) => {\n            let json = JSON.parse(body);\n            let ids = [];\n            for(let i = 0; i < json.length; i++) {\n                const id = json[i].id ?? generateID();\n                ids.push(id);\n                feeds[id] = json[i];\n            }\n            xhr.storage.ids = ids;\n            localStorage.OTDfeeds = JSON.stringify(feeds);\n            console.log('feeds push', json, ids);\n            return body;\n        },\n        afterRequest: (xhr) => {\n            return xhr.storage.ids;\n        }\n    },\n    // emulate sending columns\n    {\n        path: \"/1.1/tweetdeck/columns\",\n        method: \"POST\",\n        responseHeaderOverride: {\n            \"X-Td-Mtime\": () => {\n                return new Date().toISOString();\n            },\n        },\n        openHandler: () => {},\n        sendHandler: emulateResponse,\n        beforeSendBody: (xhr, body) => {\n            let json = JSON.parse(body);\n            let ids = [];\n            for(let i = 0; i < json.length; i++) {\n                const id = json[i].id ?? generateID();\n                ids.push(id);\n                columns[id] = json[i];\n            }\n            xhr.storage.ids = ids;\n            localStorage.OTDcolumns = JSON.stringify(columns);\n            console.log('columns push', json, ids);\n            return body;\n        },\n        afterRequest: (xhr) => {\n            return xhr.storage.ids;\n        }\n    },\n    // tweetdeck stuff\n    {\n        path: \"/decider\",\n        method: \"GET\",\n        openHandler: () => {},\n        sendHandler: emulateResponse,\n        afterRequest: (xhr) => {\n            console.log(\"Got decider\");\n            return {\"decider\":{\"tweetdeck_subsequent_follows\":true,\"scheduler_write\":true,\"in_reply_to_indicator\":true,\"enable_cors_firefox\":true,\"create_moment\":true,\"simplified_edit_collection_flow\":true,\"suggest_refresh\":true,\"poll_streamed_feed_favorites\":true,\"disable_oauth_echo\":true,\"scheduler_read_visible\":true,\"upload_big_gifs\":true,\"cookie_force_migrate\":true,\"action_retweeted_retweet\":true,\"native_animated_gifs\":true,\"touchdeck_sidebar_v2\":true,\"account_settings_join_team_flow\":true,\"enable_rewrite_columns\":true,\"touchdeck_font_size_v2\":true,\"touchdeck_search_v2\":true,\"disable_typeahead_search_with_feather_v2\":true,\"dataminr_proxied_auth_flow\":true,\"disable_streaming\":true,\"abuse_emergency_filter_info\":true,\"poll_streamed_feed_home\":true,\"compose_quoted_tweet_as_attachment\":true,\"send_twitter_auth_type_header\":true,\"dataminr\":true,\"heartfave_animation\":true,\"touchdeck_column_options_v2\":true,\"tweets_emoji\":true,\"column_unread_bar\":true,\"with_video_upload\":true,\"continuous_pipeline_staging\":true,\"universal_search_timelines\":true,\"machine_translated_tweets\":true,\"hashflags\":true,\"scheduler_read_background\":true,\"cookie_streaming\":true,\"poll_streamed_feed_usertweets\":true,\"faster_notifications\":true,\"disable_scheduled_messages\":true,\"streamed_chirp_lookup_metrics\":true,\"tweet_up_to_four_images\":true,\"sample_failed_requests\":true,\"iq_tweets\":true,\"add_column_by_url_query_param\":true,\"use_twitter_api_sync\":true,\"track_search_engagement\":true,\"quote_tweet_read\":true,\"cookie_access_tweetdeck\":true,\"account_settings_redesign\":true,\"windows_migration_logged_in_2\":true,\"tweetstorms\":true,\"action_favorited_retweet\":true,\"tweetdeck_subsequent_likes\":true,\"touchdeck_tweet_controls_v3\":true,\"trends_tailored\":true,\"live_video_timelines\":true,\"slow_collection_refresh\":true,\"fetch_entire_blocklist\":true,\"report_flow_iframe\":true,\"tweet_hide_suffix\":true,\"windows_migration_warning_2\":true,\"version_poll_force_upgrade\":true,\"quote_tweet_write\":true,\"poll_cards_enabled\":true,\"version_poll\":true,\"migrate_chrome_app_session_to_web\":true,\"add_account\":true,\"disable_quote_tweet_unavailable_msg\":true,\"convert_new_oauth_account_to_contributor\":true,\"iq_rts\":true,\"migrate_mac_app_session_to_web_gt_3_9_482\":true,\"enable_cors_2\":true,\"windows_migration_logged_out_2\":true,\"simplified_replies\":true,\"scheduler_write_media\":true,\"multi_photo_media_grid\":true,\"touchdeck_modals_v2\":true,\"non_destructive_chirp_rerender\":true,\"touchdeck_dropdowns_v2\":true,\"umf_prompts\":true,\"cramming\":true,\"trends_regional\":true,\"cookie_td_cookie_migration\":true,\"universal_search_timelines_by_id\":true,\"add_account_via_xauth_2\":true,\"native_video\":true,\"chirp_lateness_metric\":true,\"upload_use_sru\":true,\"mute_conversation\":true,\"action_quoted_tweet\":true,\"dm_rounded_avatars\":true,\"compose_character_limit_do_not_count_attachments\":true,\"touchdeck_compose_v2\":true,\"autocomplete_remote_sources\":true,\"cards_enabled_detail_view\":true}};\n        },\n    },\n    {\n        path: \"/web/dist/version.json\",\n        method: \"GET\",\n        openHandler: () => {},\n        sendHandler: emulateResponse,\n        afterRequest: (xhr) => {\n            console.log(\"Got version.json\");\n            return {\"version\":\"4.0.220811153004\",\"minimum\":\"4.0.190610153508\"};\n        },\n    },\n    {\n        path: \"/1.1/help/settings.json\",\n        method: \"GET\",\n        openHandler: () => {},\n        sendHandler: emulateResponse,\n        afterRequest: (xhr) => {\n            console.log(\"Got settings.json\");\n            return {\"versions\":{\"feature_switches\":\"a6da3a3fb61e9c1423276a8df0da3258980b42cf\",\"experiments\":\"a6da3a3fb61e9c1423276a8df0da3258980b42cf\",\"settings\":\"a88b5266c59f52ccf8a8f1fd85f2b92a\"},\"config\":{\"live_engagement_in_column_8020\":{\"value\":\"live_engagement_enabled\"},\"tweetdeck_activity_streaming\":{\"value\":false},\"tweetdeck_content_render_search_tweets\":{\"value\":true},\"tweetdeck_live_engagements\":{\"value\":true},\"tweetdeck_scheduled_new_api\":{\"value\":true},\"tweetdeck_trends_column\":{\"value\":true},\"twitter_text_emoji_counting_enabled\":{\"value\":true}},\"impression_pointers\":{}};\n        },\n    },\n    {\n        path: \"/i/jot\",\n        method: \"GET\",\n        openHandler: () => {},\n        sendHandler: emulateResponse,\n        afterRequest: (xhr) => {\n            return \"\";\n        },\n    },\n];\n\n// wrap the XMLHttpRequest\nXMLHttpRequest = function () {\n    return new Proxy(new OriginalXHR(), {\n        open(method, url, async, username = null, password = null) {\n            this.modMethod = method;\n            this.modUrl = url;\n            this.originalUrl = url;\n            this.modReqHeaders = {};\n            this.storage = {};\n\n\n            try {\n                let parsedUrl = new URL(url);\n                this.proxyRoute = proxyRoutes.find((route) => {\n                    if(!route) return false;\n                    if (route.method.toUpperCase() !== method.toUpperCase()) return false;\n                    if (typeof route.path === \"string\") {\n                        return route.path === parsedUrl.pathname;\n                    } else if (route.path instanceof RegExp) {\n                        return route.path.test(parsedUrl.pathname);\n                    }\n                });\n            } catch (e) {\n                console.error(e);\n            }\n            if (this.proxyRoute && this.proxyRoute.beforeRequest) {\n                this.proxyRoute.beforeRequest(this);\n            }\n\n            // both handlers must be set, because if openHandler never opens the request 'send' will always error\n            if(this.proxyRoute && this.proxyRoute.openHandler && this.proxyRoute.sendHandler) {\n                this.proxyRoute.openHandler(this, this.modMethod, this.modUrl, async, username, password);\n            } else {\n                this.open(this.modMethod, this.modUrl, async, username, password);\n            }\n        },\n        setRequestHeader(name, value) {\n            this.modReqHeaders[name] = value;\n        },\n        async send(body = null) {\n            let parsedUrl = new URL(this.modUrl);\n            let method = this.modMethod;\n            if(!method) {\n                method = \"GET\";\n            } else {\n                method = method.toUpperCase();\n            }\n            if(\n                this.readyState === 1 &&\n                (\n                    this.modUrl.includes(\"api.twitter.com\") || \n                    this.modUrl.includes(\"api.x.com\") || \n                    this.modUrl.includes(\"twitter.com/i/api\") ||\n                    this.modUrl.includes(\"x.com/i/api\")\n                )\n            ) {\n                if(localStorage.device_id) this.setRequestHeader('X-Client-UUID', localStorage.device_id);\n                if(Date.now() - OTD_INIT_TIME < 3000 && !window.solveChallenge) {\n                    console.log('waiting for challenge');\n                    let i = 0;\n                    while(!window.solveChallenge && i++ < 50) {\n                        await new Promise(resolve => setTimeout(resolve, 100));\n                    }\n                }\n                if(window.solveChallenge) {\n                    try {\n                        this.setRequestHeader('x-client-transaction-id', await solveChallenge(parsedUrl.pathname, method));\n                    } catch (e) {\n                        // if(localStorage.secureRequests) {\n                            console.error(`Challenge error for ${method} ${parsedUrl.pathname}:`, e);\n                            throw e;\n                        // }\n                    }\n                }\n            }\n            if (this.proxyRoute && this.proxyRoute.beforeSendHeaders) {\n                this.proxyRoute.beforeSendHeaders(this);\n            }\n            try {\n                for (const [name, value] of Object.entries(this.modReqHeaders)) {\n                    this.setRequestHeader(name, value);\n                }\n            } catch(e) {\n                if(!String(e).includes('OPENED')) {\n                    console.error(e);\n                }\n            }\n            if (this.proxyRoute && this.proxyRoute.beforeSendBody) {\n                body = this.proxyRoute.beforeSendBody(this, body);\n            }\n            if(this.proxyRoute && this.proxyRoute.sendHandler) {\n                this.proxyRoute.sendHandler(this, body);\n            } else {\n                this.send(body);\n            }\n        },\n        get(xhr, key) {\n            if (!key in xhr) return undefined;\n            if (key === \"responseText\" && xhr._responseText) return xhr._responseText;\n            if (key === \"responseText\") return this.interceptResponseText(xhr);\n            if (key === \"readyState\" && xhr._readyState) return xhr._readyState;\n            if (key === \"status\" && xhr._status) return xhr._status;\n            if (key === \"statusText\" && (xhr._statusText || xhr._status)) return xhr._statusText ? xhr._statusText : xhr._status+\"\";\n\n            let value = xhr[key];\n            if (typeof value === \"function\") {\n                value = this[key] || value;\n                return (...args) => value.apply(xhr, args);\n            } else {\n                return value;\n            }\n        },\n        set(xhr, key, value) {\n            if (key in xhr) {\n                xhr[key] = value;\n            }\n            return value;\n        },\n        interceptResponseText(xhr) {\n            if (xhr.proxyRoute && xhr.proxyRoute.afterRequest) {\n                let out = xhr.proxyRoute.afterRequest(xhr);\n                if (typeof out === \"object\") {\n                    return JSON.stringify(out);\n                } else {\n                    return out;\n                }\n            }\n            return xhr.responseText;\n        },\n        getResponseHeader(name) {\n            let override = this.responseHeaderOverride ? this.responseHeaderOverride : this.proxyRoute ? this.proxyRoute.responseHeaderOverride : undefined;\n            if(this.proxyRoute && override) {\n                for(let header in override) {\n                    if(header.toLowerCase() === name.toLowerCase()) {\n                        return override[header](this.getResponseHeader(header));\n                    }\n                }\n            }\n            return this.getResponseHeader(name);\n        },\n        getAllResponseHeaders() {\n            let headers = this.getAllResponseHeaders();\n\n            let override = this.responseHeaderOverride ? this.responseHeaderOverride : this.proxyRoute ? this.proxyRoute.responseHeaderOverride : undefined;\n            if (this.proxyRoute && override) {\n                let splitHeaders = headers.split(\"\\r\\n\");\n                let objHeaders = {};\n                for (let header of splitHeaders) {\n                    let splitHeader = header.split(\": \");\n                    let headerName = splitHeader[0];\n                    let headerValue = splitHeader[1];\n                    objHeaders[headerName.toLowerCase()] = headerValue;\n                }\n                for(let header in override) {\n                    objHeaders[header.toLowerCase()] = override[header](objHeaders[header.toLowerCase()], objHeaders);\n                }\n                headers = Object.entries(objHeaders).filter(([_, value]) => value).map(([name, value]) => `${name}: ${value}`).join(\"\\r\\n\");\n            }\n\n            return headers;\n        },\n    });\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/engine/project/src/notifications.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]